type token =
  | DCATCH
  | DCLASS
  | DEND
  | DFIELD
  | DLIMIT
  | DLINE
  | DMETHOD
  | DSET
  | DSUPER
  | DSOURCE
  | DTHROWS
  | DVAR
  | DIMPLEMENTS
  | DINTERFACE
  | DBYTECODE
  | DDEBUG
  | DENCLOSING
  | DSIGNATURE
  | DSTACK
  | DATTRIBUTE
  | DDEPRECATED
  | DINNER
  | DANNOTATION
  | USING
  | IS
  | FROM
  | METHOD
  | SIGNATURE
  | STACK
  | OFFSET
  | LOCALS
  | FIELD
  | CLASS
  | TO
  | INNER
  | OUTER
  | VISIBLE
  | INVISIBLE
  | VISIBLEPARAM
  | INVISIBLEPARAM
  | USE
  | ABSTRACT
  | FINAL
  | INTERFACE
  | NATIVE
  | PRIVATE
  | PROTECTED
  | PUBLIC
  | STATIC
  | SYNCHRONIZED
  | TRANSIENT
  | VOLATILE
  | ANNOTATION
  | ENUM
  | BRIDGE
  | VARARGS
  | STRICT
  | SYNTHETIC
  | LOOKUPSWITCH
  | TABLESWITCH
  | DEFAULT
  | EQ
  | SEP
  | COLON
  | Str of (string)
  | Word of (string)
  | Insn of (string * string)
  | Int of (int)
  | Num of (string)
  | Relative of (string)
  | EOF

open Parsing;;
let _ = parse_error;;
# 2 "parser.mly"
  open JData
  open JWriter
  open JCode
  open JCodeWriter

(*let debug = debug0*)

  type switchcase = 
    | CaseIntWord of int * string
    | CaseIntInt of int * int

  type switchdefault =
    | DefaultWord of string
    | DefaultInt of int


  let unescape s =
    Scanf.unescaped (String.sub s 1 ((String.length s)- 2))

  let cbasic = function 
      | "boolean" -> "Z"
      | "byte"    -> "B"
      | "char"    -> "C"
      | "short"   -> "S"
      | "int"     -> "I"
      | "long"    -> "J"
      | "float"   -> "F"
      | "double"  -> "D"
      | "void"    -> "V"
      | _ -> assert false

  let java_basic_type_of_string = function
      | "boolean" -> `Bool
      | "char" -> `Char
      | "float" -> `Float
      | "double" -> `Double
      | "byte" -> `Byte
      | "short" -> `Short
      | "int" -> `Int
      | "long" -> `Long
      | _ -> assert false

  let cf_access a =
    if List.mem `Public a then `Public else
    if List.mem `Protected a then `Protected else
    if List.mem `Private a then `Private else
    `Default

  let replace_dot s =
    let s = String.copy s in
    for i = 0 to String.length s - 1 do
      if s.[i] = '.' then s.[i] <- '/'
    done;
    s

  let split_method name =
    let pos = String.index name '(' in
    (String.sub name 0 pos, String.sub name pos ((String.length name) - pos))

  let split_obj name =
    let name = replace_dot name in
    let pos = String.rindex name '/' in
    (String.sub name 0 pos, String.sub name (pos+1) ((String.length name) - (pos+1)))

  let back_ch = ref (IO.output_string())
  let ctx = ref (new_ctx !back_ch ([||],[||]))

  let sourcefile = ref None
  let cn = ref ([],"_")
  let limit_stack = ref 0
  let limit_locals = ref 0
  let pos = ref 0
  let lines = ref []
  let excs = ref []
  let throws = ref []
  let label2pos = Hashtbl.create 16
  let pos2label = Hashtbl.create 16

  let init_method () =
    back_ch := !ctx.ch;
    limit_stack := 255;
    limit_locals := 255;
    pos := 0;
    lines := [];
    excs := [];
    throws := [];
    Hashtbl.clear label2pos;
    Hashtbl.clear pos2label

  let label2int l =
    if (Hashtbl.mem label2pos l) then Hashtbl.find label2pos l else
    let pos = -(1 + (Hashtbl.length pos2label)) in
    Hashtbl.add pos2label pos l;
    pos

  let addlabel l i =
    Hashtbl.add label2pos l i

  let add n c =
    let p = !pos in
    pos := !pos + n;
    (p, c)

  let mkcode codes =

    let realloc p l =
      if l >= 0 then l - p else
      let label = Hashtbl.find pos2label l in
      (Hashtbl.find label2pos label) - p

    in
    let code = Array.create !pos JCode.OpInvalid in
    List.iter (function 
      | (p, JCode.OpInvalid) -> ()
      | (p, JCode.OpIfEq(l)) -> code.(p) <- JCode.OpIfEq(realloc p l)
      | (p, JCode.OpIfNe(l)) -> code.(p) <- JCode.OpIfNe(realloc p l)
      | (p, JCode.OpIfLt(l)) -> code.(p) <- JCode.OpIfLt(realloc p l)
      | (p, JCode.OpIfGe(l)) -> code.(p) <- JCode.OpIfGe(realloc p l)
      | (p, JCode.OpIfGt(l)) -> code.(p) <- JCode.OpIfGt(realloc p l)
      | (p, JCode.OpIfLe(l)) -> code.(p) <- JCode.OpIfLe(realloc p l)
      | (p, JCode.OpICmpEq(l)) -> code.(p) <- JCode.OpICmpEq(realloc p l)
      | (p, JCode.OpICmpNe(l)) -> code.(p) <- JCode.OpICmpNe(realloc p l)
      | (p, JCode.OpICmpLt(l)) -> code.(p) <- JCode.OpICmpLt(realloc p l)
      | (p, JCode.OpICmpGe(l)) -> code.(p) <- JCode.OpICmpGe(realloc p l)
      | (p, JCode.OpICmpGt(l)) -> code.(p) <- JCode.OpICmpGt(realloc p l)
      | (p, JCode.OpICmpLe(l)) -> code.(p) <- JCode.OpICmpLe(realloc p l)
      | (p, JCode.OpACmpEq(l)) -> code.(p) <- JCode.OpACmpEq(realloc p l)
      | (p, JCode.OpACmpNe(l)) -> code.(p) <- JCode.OpACmpNe(realloc p l)
      | (p, JCode.OpGoto(l)) -> code.(p) <- JCode.OpGoto(realloc p l)
      | (p, JCode.OpJsr(l)) -> code.(p) <- JCode.OpJsr(realloc p l)
      | (p, JCode.OpLookupSwitch(d,cases)) ->
        let cases = List.map(fun(a,b)-> (a ,realloc p b)) cases in
        code.(p) <- JCode.OpLookupSwitch(realloc p d ,cases)
      | (p, JCode.OpTableSwitch (def, low, high, defs)) ->
        let defs = Array.map (realloc p) defs in
        code.(p) <- JCode.OpTableSwitch(realloc p def,low, high, defs)
      | (p, c) -> code.(p) <- c
    ) codes;
    let lines = if !lines = [] then None else Some (List.rev !lines) in
    let excs = List.map (fun exc ->
        {
          exc with
          JCode.e_start = realloc 0 exc.JCode.e_start;
          e_end = realloc 0 exc.e_end;
          e_handler = realloc 0 exc.e_handler
        }
    ) (List.rev !excs) in
    let throws = List.rev !throws in
    (code,lines, excs, throws)
# 227 "parser.ml"
let yytransl_const = [|
  257 (* DCATCH *);
  258 (* DCLASS *);
  259 (* DEND *);
  260 (* DFIELD *);
  261 (* DLIMIT *);
  262 (* DLINE *);
  263 (* DMETHOD *);
  264 (* DSET *);
  265 (* DSUPER *);
  266 (* DSOURCE *);
  267 (* DTHROWS *);
  268 (* DVAR *);
  269 (* DIMPLEMENTS *);
  270 (* DINTERFACE *);
  271 (* DBYTECODE *);
  272 (* DDEBUG *);
  273 (* DENCLOSING *);
  274 (* DSIGNATURE *);
  275 (* DSTACK *);
  276 (* DATTRIBUTE *);
  277 (* DDEPRECATED *);
  278 (* DINNER *);
  279 (* DANNOTATION *);
  280 (* USING *);
  281 (* IS *);
  282 (* FROM *);
  283 (* METHOD *);
  284 (* SIGNATURE *);
  285 (* STACK *);
  286 (* OFFSET *);
  287 (* LOCALS *);
  288 (* FIELD *);
  289 (* CLASS *);
  290 (* TO *);
  291 (* INNER *);
  292 (* OUTER *);
  293 (* VISIBLE *);
  294 (* INVISIBLE *);
  295 (* VISIBLEPARAM *);
  296 (* INVISIBLEPARAM *);
  297 (* USE *);
  298 (* ABSTRACT *);
  299 (* FINAL *);
  300 (* INTERFACE *);
  301 (* NATIVE *);
  302 (* PRIVATE *);
  303 (* PROTECTED *);
  304 (* PUBLIC *);
  305 (* STATIC *);
  306 (* SYNCHRONIZED *);
  307 (* TRANSIENT *);
  308 (* VOLATILE *);
  309 (* ANNOTATION *);
  310 (* ENUM *);
  311 (* BRIDGE *);
  312 (* VARARGS *);
  313 (* STRICT *);
  314 (* SYNTHETIC *);
  315 (* LOOKUPSWITCH *);
  316 (* TABLESWITCH *);
  317 (* DEFAULT *);
  318 (* EQ *);
  319 (* SEP *);
  320 (* COLON *);
    0 (* EOF *);
    0|]

let yytransl_block = [|
  321 (* Str *);
  322 (* Word *);
  323 (* Insn *);
  324 (* Int *);
  325 (* Num *);
  326 (* Relative *);
    0|]

let yylhs = "\255\255\
\001\000\002\000\002\000\003\000\012\000\012\000\018\000\014\000\
\014\000\019\000\007\000\007\000\008\000\008\000\008\000\009\000\
\009\000\021\000\020\000\022\000\022\000\023\000\023\000\024\000\
\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
\010\000\011\000\011\000\025\000\025\000\026\000\015\000\015\000\
\027\000\027\000\028\000\029\000\031\000\033\000\032\000\032\000\
\034\000\034\000\034\000\034\000\030\000\030\000\035\000\035\000\
\036\000\037\000\037\000\039\000\038\000\038\000\040\000\040\000\
\042\000\041\000\041\000\044\000\045\000\046\000\047\000\047\000\
\017\000\017\000\048\000\048\000\049\000\013\000\013\000\016\000\
\016\000\050\000\050\000\051\000\052\000\005\000\005\000\053\000\
\053\000\054\000\054\000\054\000\055\000\055\000\056\000\058\000\
\057\000\057\000\060\000\060\000\061\000\061\000\061\000\061\000\
\059\000\059\000\059\000\043\000\043\000\004\000\004\000\062\000\
\062\000\063\000\063\000\064\000\064\000\065\000\065\000\066\000\
\066\000\006\000\006\000\067\000\067\000\068\000\068\000\069\000\
\071\000\070\000\070\000\072\000\073\000\073\000\073\000\073\000\
\073\000\076\000\076\000\075\000\075\000\075\000\075\000\075\000\
\075\000\075\000\075\000\075\000\075\000\075\000\075\000\077\000\
\077\000\077\000\084\000\084\000\078\000\078\000\078\000\079\000\
\080\000\081\000\081\000\082\000\083\000\083\000\088\000\089\000\
\089\000\085\000\086\000\090\000\090\000\090\000\091\000\091\000\
\092\000\093\000\093\000\093\000\093\000\093\000\093\000\087\000\
\074\000\074\000\094\000\094\000\094\000\094\000\094\000\094\000\
\094\000\094\000\094\000\095\000\095\000\096\000\098\000\099\000\
\099\000\101\000\101\000\100\000\100\000\097\000\102\000\102\000\
\103\000\103\000\105\000\105\000\104\000\104\000\000\000"

let yylen = "\002\000\
\005\000\001\000\000\000\011\000\003\000\000\000\001\000\003\000\
\000\000\000\000\003\000\000\000\003\000\003\000\000\000\004\000\
\004\000\001\000\001\000\001\000\000\000\002\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\003\000\001\000\000\000\002\000\001\000\003\000\001\000\000\000\
\002\000\001\000\003\000\002\000\002\000\002\000\003\000\003\000\
\003\000\003\000\004\000\004\000\001\000\000\000\002\000\001\000\
\003\000\002\000\003\000\002\000\002\000\001\000\002\000\001\000\
\001\000\002\000\001\000\004\000\001\000\003\000\001\000\002\000\
\001\000\000\000\002\000\001\000\003\000\004\000\000\000\001\000\
\000\000\002\000\001\000\003\000\002\000\001\000\000\000\002\000\
\001\000\008\000\006\000\004\000\002\000\000\000\005\000\003\000\
\001\000\000\000\002\000\001\000\003\000\003\000\003\000\004\000\
\001\000\001\000\001\000\001\000\001\000\001\000\000\000\002\000\
\001\000\007\000\007\000\001\000\000\000\002\000\000\000\002\000\
\000\000\001\000\000\000\001\000\002\000\003\000\002\000\004\000\
\003\000\002\000\001\000\002\000\001\000\001\000\001\000\001\000\
\000\000\002\000\003\000\002\000\002\000\002\000\002\000\002\000\
\002\000\002\000\002\000\002\000\004\000\004\000\002\000\009\000\
\005\000\009\000\002\000\000\000\002\000\002\000\002\000\001\000\
\001\000\007\000\007\000\002\000\003\000\004\000\003\000\001\000\
\000\000\001\000\002\000\003\000\003\000\000\000\002\000\000\000\
\002\000\002\000\003\000\003\000\002\000\003\000\003\000\002\000\
\001\000\001\000\001\000\003\000\002\000\002\000\002\000\003\000\
\003\000\002\000\002\000\002\000\002\000\003\000\001\000\002\000\
\001\000\004\000\004\000\003\000\003\000\003\000\002\000\003\000\
\002\000\001\000\002\000\002\000\003\000\003\000\002\000"

let yydefred = "\000\000\
\000\000\000\000\002\000\223\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\121\000\000\000\000\000\011\000\
\000\000\000\000\000\000\000\000\094\000\000\000\120\000\000\000\
\000\000\000\000\000\000\000\000\034\000\028\000\033\000\032\000\
\025\000\026\000\024\000\027\000\029\000\031\000\030\000\035\000\
\036\000\037\000\038\000\039\000\040\000\000\000\019\000\020\000\
\000\000\000\000\000\000\000\000\000\000\001\000\000\000\132\000\
\000\000\096\000\013\000\014\000\000\000\000\000\000\000\000\000\
\124\000\000\000\022\000\000\000\000\000\000\000\000\000\010\000\
\000\000\000\000\000\000\108\000\000\000\133\000\143\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\010\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\135\000\139\000\000\000\141\000\142\000\144\000\193\000\
\194\000\018\000\000\000\000\000\000\000\000\000\000\000\042\000\
\000\000\000\000\000\000\000\000\000\000\007\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\100\000\107\000\
\000\000\000\000\152\000\000\000\000\000\000\000\000\000\149\000\
\168\000\150\000\000\000\153\000\169\000\151\000\000\000\148\000\
\154\000\000\000\178\000\159\000\000\000\155\000\156\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\207\000\204\000\
\000\000\000\000\205\000\000\000\146\000\202\000\000\000\000\000\
\198\000\203\000\000\000\134\000\138\000\140\000\016\000\017\000\
\041\000\000\000\000\000\000\000\044\000\126\000\000\000\000\000\
\000\000\000\000\000\000\000\000\109\000\093\000\110\000\111\000\
\000\000\000\000\000\000\000\000\000\000\064\000\000\000\000\000\
\136\000\000\000\137\000\166\000\165\000\167\000\115\000\116\000\
\113\000\114\000\172\000\117\000\000\000\176\000\000\000\000\000\
\000\000\000\000\184\000\000\000\000\000\000\000\000\000\068\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\215\000\
\000\000\000\000\000\000\000\000\000\000\201\000\200\000\196\000\
\147\000\046\000\000\000\000\000\000\000\128\000\122\000\123\000\
\000\000\101\000\000\000\055\000\056\000\000\000\000\000\112\000\
\000\000\063\000\000\000\104\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\173\000\000\000\057\000\058\000\
\000\000\000\000\157\000\080\000\158\000\000\000\000\000\000\000\
\206\000\208\000\216\000\219\000\220\000\000\000\214\000\217\000\
\005\000\000\000\010\000\000\000\000\000\067\000\054\000\053\000\
\000\000\065\000\000\000\000\000\072\000\073\000\075\000\000\000\
\000\000\000\000\174\000\175\000\181\000\180\000\192\000\000\000\
\000\000\183\000\000\000\059\000\060\000\078\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\050\000\
\000\000\098\000\077\000\000\000\069\000\071\000\074\000\000\000\
\000\000\000\000\000\000\000\000\000\000\185\000\210\000\211\000\
\212\000\213\000\221\000\222\000\086\000\008\000\052\000\000\000\
\000\000\000\000\091\000\049\000\000\000\000\000\000\000\000\000\
\163\000\000\000\190\000\191\000\187\000\188\000\000\000\000\000\
\004\000\000\000\084\000\090\000\051\000\076\000\170\000\171\000\
\000\000\000\000\092\000\000\000\083\000\000\000\000\000\085\000\
\160\000\162\000"

let yydgoto = "\002\000\
\004\000\005\000\007\000\011\000\020\000\054\000\008\000\015\000\
\028\000\064\000\111\000\180\000\245\000\036\001\070\001\097\001\
\113\001\119\000\122\000\046\000\107\000\047\000\048\000\049\000\
\112\000\113\000\071\001\072\001\073\001\196\000\000\001\125\000\
\001\001\157\000\197\000\198\000\199\000\042\001\158\000\043\001\
\044\001\045\001\046\001\047\001\076\001\227\000\228\000\114\001\
\115\001\098\001\099\001\121\000\021\000\022\000\188\000\052\000\
\074\000\127\000\212\000\075\000\076\000\012\000\013\000\066\000\
\115\000\184\000\055\000\056\000\057\000\097\000\098\000\099\000\
\100\000\101\000\102\000\103\000\144\000\136\000\138\000\142\000\
\131\000\140\000\148\000\083\001\149\000\218\000\013\001\215\000\
\216\000\219\000\014\001\058\001\059\001\104\000\105\000\160\000\
\163\000\161\000\230\000\025\001\231\000\164\000\236\000\031\001\
\237\000"

let yysindex = "\025\000\
\008\255\000\000\000\000\000\000\082\255\043\255\133\255\130\255\
\097\255\253\254\159\255\133\255\000\000\041\255\074\255\000\000\
\072\255\072\255\072\255\160\255\000\000\159\255\000\000\113\255\
\116\255\072\255\072\255\182\255\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\128\255\000\000\000\000\
\072\255\128\255\131\255\148\255\072\255\000\000\160\255\000\000\
\090\255\000\000\000\000\000\000\132\255\132\255\132\255\183\255\
\000\000\164\255\000\000\164\255\134\255\137\255\138\255\000\000\
\025\255\192\255\148\255\000\000\139\255\000\000\000\000\132\255\
\176\255\242\254\140\255\141\255\132\255\142\255\137\255\231\254\
\138\255\000\000\044\255\143\255\144\255\145\255\067\255\147\255\
\090\255\000\000\000\000\150\255\000\000\000\000\000\000\000\000\
\000\000\000\000\151\255\152\255\153\255\132\255\199\255\000\000\
\183\255\132\255\184\255\184\255\240\254\000\000\155\255\154\255\
\158\255\161\255\132\255\132\255\156\255\191\255\000\000\000\000\
\162\255\200\255\000\000\165\255\163\255\167\255\168\255\000\000\
\000\000\000\000\215\254\000\000\000\000\000\000\202\255\000\000\
\000\000\169\255\000\000\000\000\203\255\000\000\000\000\132\255\
\132\255\170\255\171\255\178\255\156\255\179\255\000\000\000\000\
\172\255\237\254\000\000\026\255\000\000\000\000\079\255\175\255\
\000\000\000\000\020\255\000\000\000\000\000\000\000\000\000\000\
\000\000\181\255\137\255\212\255\000\000\000\000\132\255\185\255\
\186\255\187\255\073\255\188\255\000\000\000\000\000\000\000\000\
\190\255\193\255\180\255\227\255\156\255\000\000\195\255\196\255\
\000\000\080\255\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\189\255\000\000\203\255\201\255\
\085\255\231\255\000\000\197\255\208\255\132\255\132\255\000\000\
\227\255\210\255\227\255\222\255\194\255\229\255\172\255\000\000\
\228\255\232\255\235\255\233\255\026\255\000\000\000\000\000\000\
\000\000\000\000\236\255\215\255\226\255\000\000\000\000\000\000\
\241\255\000\000\000\000\000\000\000\000\238\255\010\000\000\000\
\247\255\000\000\244\254\000\000\216\255\220\255\246\255\231\255\
\006\000\011\000\012\000\035\000\000\000\123\255\000\000\000\000\
\014\000\020\000\000\000\000\000\000\000\244\254\104\255\008\000\
\000\000\000\000\000\000\000\000\000\000\027\000\000\000\000\000\
\000\000\030\000\000\000\043\000\032\000\000\000\000\000\000\000\
\034\000\000\000\096\255\044\000\000\000\000\000\000\000\038\000\
\031\000\081\000\000\000\000\000\000\000\000\000\000\000\045\000\
\046\000\000\000\047\000\000\000\000\000\000\000\050\000\051\000\
\109\255\114\255\053\000\054\000\025\255\098\000\043\000\000\000\
\156\255\000\000\000\000\156\255\000\000\000\000\000\000\095\000\
\096\000\057\000\097\000\117\255\118\255\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\138\255\
\108\000\098\000\000\000\000\000\227\255\227\255\059\000\060\000\
\000\000\121\255\000\000\000\000\000\000\000\000\063\000\062\000\
\000\000\108\000\000\000\000\000\000\000\000\000\000\000\000\000\
\100\000\101\000\000\000\067\000\000\000\065\000\061\000\000\000\
\000\000\000\000"

let yyrindex = "\000\000\
\129\255\000\000\000\000\000\000\058\255\000\000\002\000\075\255\
\000\000\000\000\004\000\003\000\000\000\000\000\000\000\000\000\
\241\254\241\254\070\000\132\001\000\000\005\000\000\000\000\000\
\000\000\070\000\070\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\243\254\000\000\000\000\
\004\255\243\254\000\000\130\000\070\000\000\000\137\001\000\000\
\075\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\
\000\000\252\254\000\000\252\254\000\000\000\000\000\000\000\000\
\000\000\000\000\136\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\077\000\000\000\
\075\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\029\000\000\000\
\009\000\000\000\079\000\079\000\080\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\138\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\113\000\000\000\000\000\016\255\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\138\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\082\000\083\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\037\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\144\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\016\255\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\087\000\000\000\000\000\000\000\000\000\089\000\000\000\
\000\000\000\000\000\000\000\000\090\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\064\000\000\000\000\000\000\000\
\080\000\000\000\058\000\000\000\000\000\091\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\145\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\078\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\007\255\000\000\000\000\000\000\000\000\
\000\000\248\254\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\086\000\085\000\000\000\
\138\000\000\000\000\000\138\000\000\000\000\000\000\000\000\000\
\000\000\000\000\092\000\155\255\093\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\033\000\099\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\066\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000"

let yygindex = "\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\177\255\166\255\016\000\207\255\000\000\103\001\000\000\
\041\001\000\000\000\000\088\000\000\000\105\255\091\255\094\000\
\219\255\000\000\000\000\216\000\000\000\139\000\000\000\000\000\
\000\000\115\000\021\001\118\000\000\000\000\000\000\000\000\000\
\052\000\000\000\069\000\174\255\142\001\000\000\172\000\000\000\
\000\000\000\000\237\000\000\000\094\001\000\000\158\001\121\001\
\104\001\057\001\000\000\119\001\000\000\000\000\078\001\079\001\
\000\000\006\001\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\219\000\171\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\205\000\000\000\000\000\000\000\200\000\000\000\
\000\000"

let yytablesize = 437
let yytable = "\151\000\
\043\000\119\000\118\000\095\000\097\000\225\000\150\000\145\000\
\045\000\070\000\041\001\186\000\108\000\109\000\133\000\146\000\
\134\000\164\000\182\000\021\000\021\000\125\000\125\000\207\000\
\208\000\001\000\209\000\210\000\006\000\017\000\130\000\127\000\
\082\000\050\000\051\000\141\000\087\000\147\000\023\000\023\000\
\018\000\061\000\062\000\232\000\182\000\187\000\182\000\021\000\
\233\000\125\000\021\000\135\000\207\000\208\000\164\000\209\000\
\210\000\099\000\127\000\012\000\178\000\123\000\124\000\009\000\
\182\000\081\000\023\000\012\000\077\000\023\000\003\000\012\000\
\070\000\193\000\194\000\026\000\015\000\048\000\092\000\093\000\
\152\000\153\000\154\000\155\000\047\000\089\000\095\000\027\000\
\015\000\079\000\080\000\234\000\081\000\235\000\082\000\083\000\
\006\000\084\000\088\000\243\000\085\000\086\000\220\000\221\000\
\156\000\024\000\025\000\087\000\088\000\089\000\090\000\009\000\
\091\000\029\000\030\000\031\000\032\000\033\000\034\000\035\000\
\036\000\037\000\038\000\039\000\040\000\041\000\042\000\043\000\
\044\000\045\000\003\000\166\000\167\000\246\000\168\000\169\000\
\170\000\207\000\003\000\014\000\209\000\210\000\003\000\003\000\
\238\000\005\001\239\000\006\001\092\000\093\000\010\001\056\001\
\011\001\057\001\010\000\094\000\095\000\096\000\077\001\016\000\
\207\000\208\000\019\000\209\000\210\000\070\000\053\000\071\000\
\072\000\063\001\073\000\064\001\017\001\018\001\089\001\059\000\
\090\001\101\001\060\000\091\001\102\001\092\001\107\001\109\001\
\108\001\110\001\121\001\019\001\122\001\021\001\063\000\117\001\
\118\001\065\000\126\000\110\000\069\000\106\000\114\000\117\000\
\068\001\118\000\132\000\120\000\129\000\159\000\139\000\137\000\
\165\000\143\000\171\000\162\000\174\000\175\000\176\000\177\000\
\179\000\189\000\190\000\183\000\191\000\195\000\200\000\192\000\
\201\000\202\000\213\000\203\000\244\000\255\000\204\000\009\001\
\217\000\012\001\205\000\206\000\214\000\222\000\223\000\229\000\
\224\000\034\001\240\000\242\000\226\000\254\000\035\001\247\000\
\248\000\048\001\251\000\249\000\252\000\049\001\007\001\253\000\
\003\001\023\001\004\001\015\001\043\000\119\000\118\000\043\000\
\119\000\118\000\095\000\097\000\045\000\111\001\016\001\045\000\
\043\000\043\000\043\000\020\001\043\000\043\000\043\000\043\000\
\045\000\045\000\045\000\022\001\045\000\045\000\045\000\045\000\
\006\000\024\001\027\001\006\000\082\000\030\001\028\001\082\000\
\087\000\029\001\033\001\087\000\006\000\006\000\187\000\038\001\
\006\000\006\000\006\000\006\000\087\000\040\001\082\000\050\001\
\087\000\087\000\087\000\087\000\103\000\099\000\039\001\055\001\
\099\000\069\001\041\001\009\000\052\001\081\000\009\000\065\001\
\081\000\053\001\054\001\103\000\060\001\103\000\103\000\009\000\
\103\000\048\000\061\001\009\000\048\000\009\000\009\000\081\000\
\047\000\089\000\066\001\047\000\089\000\048\000\074\001\067\001\
\075\001\048\000\081\001\048\000\047\000\089\000\088\000\080\001\
\047\000\088\000\047\000\089\000\082\001\086\001\084\001\085\001\
\087\001\088\001\088\000\093\001\094\001\096\001\103\001\104\001\
\088\000\105\001\106\001\112\001\119\001\123\001\124\001\120\001\
\130\001\128\001\129\001\131\000\106\000\126\001\127\001\021\000\
\130\000\145\000\105\000\195\000\062\000\129\000\102\000\177\000\
\199\000\197\000\061\000\179\000\079\000\209\000\218\000\067\000\
\066\000\181\000\161\000\186\000\002\001\078\001\100\001\211\000\
\062\001\079\001\095\001\058\000\037\001\125\001\116\001\250\000\
\128\000\023\000\068\000\116\000\185\000\078\000\172\000\173\000\
\241\000\008\001\051\001\026\001\032\001"

let yycheck = "\090\000\
\000\000\000\000\000\000\000\000\000\000\157\000\089\000\087\000\
\000\000\003\001\023\001\028\001\062\000\063\000\029\001\041\001\
\031\001\026\001\003\001\035\001\036\001\035\001\036\001\065\001\
\066\001\001\000\068\001\069\001\000\000\033\001\080\000\036\001\
\000\000\018\000\019\000\085\000\000\000\063\001\035\001\036\001\
\044\001\026\000\027\000\063\001\029\001\062\001\031\001\063\001\
\068\001\063\001\066\001\066\001\065\001\066\001\063\001\068\001\
\069\001\000\000\063\001\002\001\110\000\037\001\038\001\000\000\
\114\000\000\000\063\001\010\001\053\000\066\001\063\001\014\001\
\066\001\123\000\124\000\002\001\002\001\000\000\059\001\060\001\
\037\001\038\001\039\001\040\001\000\000\000\000\067\001\014\001\
\014\001\000\001\001\001\066\001\003\001\068\001\005\001\006\001\
\015\001\008\001\000\000\179\000\011\001\012\001\152\000\153\000\
\061\001\065\001\066\001\018\001\019\001\020\001\021\001\069\001\
\023\001\042\001\043\001\044\001\045\001\046\001\047\001\048\001\
\049\001\050\001\051\001\052\001\053\001\054\001\055\001\056\001\
\057\001\058\001\002\001\065\001\066\001\183\000\068\001\069\001\
\070\001\065\001\010\001\010\001\068\001\069\001\014\001\015\001\
\066\001\066\001\068\001\068\001\059\001\060\001\066\001\029\001\
\068\001\031\001\022\001\066\001\067\001\068\001\063\001\063\001\
\065\001\066\001\004\001\068\001\069\001\018\001\007\001\020\001\
\021\001\066\001\023\001\068\001\222\000\223\000\066\001\063\001\
\068\001\073\001\063\001\066\001\076\001\068\001\066\001\066\001\
\068\001\068\001\066\001\225\000\068\001\227\000\009\001\101\001\
\102\001\066\001\003\001\013\001\066\001\066\001\035\001\066\001\
\035\001\065\001\027\001\066\001\066\001\063\001\066\001\068\001\
\064\001\068\001\064\001\068\001\063\001\063\001\063\001\063\001\
\018\001\063\001\065\001\036\001\063\001\066\001\032\001\063\001\
\063\001\026\001\025\001\063\001\017\001\003\001\068\001\031\001\
\030\001\003\001\068\001\068\001\068\001\068\001\068\001\068\001\
\063\001\027\001\068\001\063\001\066\001\066\001\021\001\063\001\
\063\001\034\001\063\001\065\001\063\001\034\001\066\001\063\001\
\062\001\064\001\063\001\063\001\004\001\004\001\004\001\007\001\
\007\001\007\001\007\001\007\001\004\001\096\001\063\001\007\001\
\016\001\017\001\018\001\066\001\020\001\021\001\022\001\023\001\
\016\001\017\001\018\001\062\001\020\001\021\001\022\001\023\001\
\004\001\061\001\063\001\007\001\004\001\061\001\063\001\007\001\
\004\001\063\001\063\001\007\001\016\001\017\001\062\001\066\001\
\020\001\021\001\022\001\023\001\016\001\063\001\022\001\066\001\
\020\001\021\001\022\001\023\001\003\001\004\001\053\001\029\001\
\007\001\023\001\023\001\004\001\063\001\004\001\007\001\064\001\
\007\001\063\001\063\001\018\001\063\001\020\001\021\001\016\001\
\023\001\004\001\063\001\020\001\007\001\022\001\023\001\022\001\
\004\001\004\001\064\001\007\001\007\001\016\001\063\001\066\001\
\063\001\020\001\068\001\022\001\016\001\016\001\004\001\066\001\
\020\001\007\001\022\001\022\001\028\001\063\001\066\001\066\001\
\063\001\063\001\016\001\063\001\063\001\020\001\024\001\024\001\
\022\001\065\001\026\001\016\001\066\001\063\001\065\001\068\001\
\068\001\063\001\066\001\000\000\003\001\034\001\034\001\066\001\
\000\000\063\001\003\001\063\001\003\001\063\001\063\001\031\001\
\063\001\063\001\003\001\003\001\062\001\061\001\061\001\049\000\
\062\001\113\000\063\001\063\001\197\000\043\001\071\001\139\000\
\022\001\044\001\069\001\022\000\249\000\114\001\098\001\187\000\
\075\000\012\000\050\000\068\000\116\000\055\000\097\000\097\000\
\171\000\215\000\008\001\231\000\237\000"

let yynames_const = "\
  DCATCH\000\
  DCLASS\000\
  DEND\000\
  DFIELD\000\
  DLIMIT\000\
  DLINE\000\
  DMETHOD\000\
  DSET\000\
  DSUPER\000\
  DSOURCE\000\
  DTHROWS\000\
  DVAR\000\
  DIMPLEMENTS\000\
  DINTERFACE\000\
  DBYTECODE\000\
  DDEBUG\000\
  DENCLOSING\000\
  DSIGNATURE\000\
  DSTACK\000\
  DATTRIBUTE\000\
  DDEPRECATED\000\
  DINNER\000\
  DANNOTATION\000\
  USING\000\
  IS\000\
  FROM\000\
  METHOD\000\
  SIGNATURE\000\
  STACK\000\
  OFFSET\000\
  LOCALS\000\
  FIELD\000\
  CLASS\000\
  TO\000\
  INNER\000\
  OUTER\000\
  VISIBLE\000\
  INVISIBLE\000\
  VISIBLEPARAM\000\
  INVISIBLEPARAM\000\
  USE\000\
  ABSTRACT\000\
  FINAL\000\
  INTERFACE\000\
  NATIVE\000\
  PRIVATE\000\
  PROTECTED\000\
  PUBLIC\000\
  STATIC\000\
  SYNCHRONIZED\000\
  TRANSIENT\000\
  VOLATILE\000\
  ANNOTATION\000\
  ENUM\000\
  BRIDGE\000\
  VARARGS\000\
  STRICT\000\
  SYNTHETIC\000\
  LOOKUPSWITCH\000\
  TABLESWITCH\000\
  DEFAULT\000\
  EQ\000\
  SEP\000\
  COLON\000\
  EOF\000\
  "

let yynames_block = "\
  Str\000\
  Word\000\
  Insn\000\
  Int\000\
  Num\000\
  Relative\000\
  "

let yyact = [|
  (fun _ -> failwith "parser")
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'sep) in
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'jasmin_header) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'inners) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'fields) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'methods) in
    Obj.repr(
# 193 "parser.mly"
    (debug "jasfile@."; _2 _3 _4 _5 )
# 753 "parser.ml"
               : jclass))
; (fun __caml_parser_env ->
    Obj.repr(
# 196 "parser.mly"
        ( () )
# 759 "parser.ml"
               : 'sep))
; (fun __caml_parser_env ->
    Obj.repr(
# 197 "parser.mly"
    ( () )
# 765 "parser.ml"
               : 'sep))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 10 : 'bytecode_spec) in
    let _2 = (Parsing.peek_val __caml_parser_env 9 : 'source_spec) in
    let _3 = (Parsing.peek_val __caml_parser_env 8 : 'class_spec) in
    let _4 = (Parsing.peek_val __caml_parser_env 7 : 'super_spec) in
    let _5 = (Parsing.peek_val __caml_parser_env 6 : 'implements) in
    let _6 = (Parsing.peek_val __caml_parser_env 5 : 'signature_spec) in
    let _7 = (Parsing.peek_val __caml_parser_env 4 : 'enclosing_spec) in
    let _8 = (Parsing.peek_val __caml_parser_env 3 : 'deprecated_spec) in
    let _9 = (Parsing.peek_val __caml_parser_env 2 : 'annotations) in
    let _10 = (Parsing.peek_val __caml_parser_env 1 : 'generic_attributes) in
    let _11 = (Parsing.peek_val __caml_parser_env 0 : 'debug_extension) in
    Obj.repr(
# 211 "parser.mly"
    (

      let (class_or_interface, access, name) = _3 in

      match class_or_interface with
      | "class" ->
        debug "class@.";
        (fun inners fields methods ->
          debug "gen@.";

          {
            cversion = _1;
            constants = ([||], (ctx_toArray !ctx));
            cpath = name;
            csuper = _4;
            cflags = access;
            cinterfaces = _5;
            cfields = fields;
            cmethods = methods;
            cattributes = (* $2::$7::$8::$9::$11 @ *) _10;
            cinner_types = inners;
            ctypes = _6;
          }
        )
      | k -> debug "error %s@." k; assert false
      (*
      | "interface" ->
        (fun inners fields methods ->
          let fields = List.fold_left (fun fields (fs,f) ->
            let f = {
                if_signature = f.cf_signature ;
                if_class_signature = f.cf_class_signature;
                if_generic_signature = f.cf_generic_signature;
                if_synthetic = f.cf_synthetic;
                if_value = f.cf_value;
                if_annotations = f.cf_annotations;
                if_other_flags = f.cf_other_flags;
                if_attributes = f.cf_attributes;
              }
            in
            JBasics.FieldMap.add fs f fields
          ) JBasics.FieldMap.empty fields in
          let methods = List.fold_left (fun methods -> function
            (ms, ConcreteMethod {
              cm_signature = signature;
              cm_class_method_signature = class_method_signature;
              cm_access = access;
              cm_generic_signature = generic_signature;
              cm_bridge = bridge;
              cm_varargs = varargs;
              cm_synthetic = synthetic;
              cm_other_flags = other_flags;
              cm_exceptions = exceptions;
              cm_attributes = attributes;
              cm_annotations = annotations;
            }) ->
            let m = {
              am_signature = signature;
              am_class_method_signature = class_method_signature;
              am_access =
                begin match access with
                | `Default -> `Default
                | `Protected -> `Protected
                | `Public -> `Public
                | `Private -> assert false
                end
              ;
              am_generic_signature = generic_signature;
              am_bridge = bridge;
              am_varargs = varargs;
              am_synthetic = synthetic;
              am_other_flags = other_flags;
              am_exceptions = exceptions;
              am_attributes = attributes;
              am_annotations = annotations;
              am_annotation_default = None;
            } in
            JBasics.MethodMap.add ms m methods
          ) JBasics.MethodMap.empty methods in
          JInterface {
            i_name = name;
            i_version = $1;
            i_access = if List.mem `Public access then `Public else `Default;
            i_interfaces = $5;
            i_generic_signature = $6;
            i_consts = [||];
            i_sourcefile = $2;
            i_deprecated = $8;
            i_source_debug_extention = $11;
            i_inner_classes = inners;
            i_initializer = None;
            i_annotation = false;
            i_annotations = $9;
            i_other_attributes = $10;
            i_other_flags = [];
            i_fields = fields;
            i_methods = methods;
          }
        )*)
    )
# 881 "parser.ml"
               : 'jasmin_header))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'signature_expr) in
    Obj.repr(
# 314 "parser.mly"
                                  ( [] )
# 888 "parser.ml"
               : 'signature_spec))
; (fun __caml_parser_env ->
    Obj.repr(
# 315 "parser.mly"
                ( [] )
# 894 "parser.ml"
               : 'signature_spec))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 318 "parser.mly"
        (  _1 )
# 901 "parser.ml"
               : 'signature_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'deprecated_expr) in
    Obj.repr(
# 322 "parser.mly"
                                    ( true )
# 908 "parser.ml"
               : 'deprecated_spec))
; (fun __caml_parser_env ->
    Obj.repr(
# 323 "parser.mly"
                  ( false )
# 914 "parser.ml"
               : 'deprecated_spec))
; (fun __caml_parser_env ->
    Obj.repr(
# 326 "parser.mly"
    ( () )
# 920 "parser.ml"
               : 'deprecated_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    Obj.repr(
# 331 "parser.mly"
    (
      debug "bytecode@.";

      let (major, minor) =
        begin try
          let pos = String.index _2 '.' in
          let len = String.length _2 in
          (String.sub _2 0 pos, String.sub _2 (pos+1) (len-pos-1))
        with e -> (_2,"0")
        end
      in
      (int_of_string major, int_of_string minor)
    )
# 939 "parser.ml"
               : 'bytecode_spec))
; (fun __caml_parser_env ->
    Obj.repr(
# 345 "parser.mly"
    (
      (45, 3)
    )
# 947 "parser.ml"
               : 'bytecode_spec))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    Obj.repr(
# 351 "parser.mly"
                    ( Some _2 )
# 954 "parser.ml"
               : 'source_spec))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    Obj.repr(
# 352 "parser.mly"
                     ( Some _2 )
# 961 "parser.ml"
               : 'source_spec))
; (fun __caml_parser_env ->
    Obj.repr(
# 353 "parser.mly"
                  ( !sourcefile )
# 967 "parser.ml"
               : 'source_spec))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'access) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'classname) in
    Obj.repr(
# 358 "parser.mly"
    (
      cn := _3;
      ("class",_2,_3)
    )
# 978 "parser.ml"
               : 'class_spec))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'access) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'classname) in
    Obj.repr(
# 363 "parser.mly"
    (
      cn := _3;
      ("interface",_2,_3)
    )
# 989 "parser.ml"
               : 'class_spec))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 369 "parser.mly"
         ( JReader.expand_path (replace_dot _1) )
# 996 "parser.ml"
               : 'classname))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'access_list) in
    Obj.repr(
# 372 "parser.mly"
                ( _1 )
# 1003 "parser.ml"
               : 'access))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'access_items) in
    Obj.repr(
# 375 "parser.mly"
                   ( _1 )
# 1010 "parser.ml"
               : 'access_list))
; (fun __caml_parser_env ->
    Obj.repr(
# 376 "parser.mly"
      ( [] )
# 1016 "parser.ml"
               : 'access_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'access_item) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'access_items) in
    Obj.repr(
# 379 "parser.mly"
                                 ( _1::_2 )
# 1024 "parser.ml"
               : 'access_items))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'access_item) in
    Obj.repr(
# 380 "parser.mly"
                    ( [_1] )
# 1031 "parser.ml"
               : 'access_items))
; (fun __caml_parser_env ->
    Obj.repr(
# 383 "parser.mly"
                 ( JPublic )
# 1037 "parser.ml"
               : 'access_item))
; (fun __caml_parser_env ->
    Obj.repr(
# 384 "parser.mly"
                  ( JPrivate )
# 1043 "parser.ml"
               : 'access_item))
; (fun __caml_parser_env ->
    Obj.repr(
# 385 "parser.mly"
                    ( JProtected )
# 1049 "parser.ml"
               : 'access_item))
; (fun __caml_parser_env ->
    Obj.repr(
# 386 "parser.mly"
                 ( JStatic )
# 1055 "parser.ml"
               : 'access_item))
; (fun __caml_parser_env ->
    Obj.repr(
# 387 "parser.mly"
                ( JFinal )
# 1061 "parser.ml"
               : 'access_item))
; (fun __caml_parser_env ->
    Obj.repr(
# 388 "parser.mly"
                       ( JSynchronized )
# 1067 "parser.ml"
               : 'access_item))
; (fun __caml_parser_env ->
    Obj.repr(
# 389 "parser.mly"
                   ( JVolatile )
# 1073 "parser.ml"
               : 'access_item))
; (fun __caml_parser_env ->
    Obj.repr(
# 390 "parser.mly"
                    ( JTransient )
# 1079 "parser.ml"
               : 'access_item))
; (fun __caml_parser_env ->
    Obj.repr(
# 391 "parser.mly"
                 ( JNative )
# 1085 "parser.ml"
               : 'access_item))
; (fun __caml_parser_env ->
    Obj.repr(
# 392 "parser.mly"
                    ( JInterface )
# 1091 "parser.ml"
               : 'access_item))
; (fun __caml_parser_env ->
    Obj.repr(
# 393 "parser.mly"
                   ( JAbstract )
# 1097 "parser.ml"
               : 'access_item))
; (fun __caml_parser_env ->
    Obj.repr(
# 394 "parser.mly"
                     ( JAnnotation )
# 1103 "parser.ml"
               : 'access_item))
; (fun __caml_parser_env ->
    Obj.repr(
# 395 "parser.mly"
               ( JEnum )
# 1109 "parser.ml"
               : 'access_item))
; (fun __caml_parser_env ->
    Obj.repr(
# 396 "parser.mly"
                 ( JBridge )
# 1115 "parser.ml"
               : 'access_item))
; (fun __caml_parser_env ->
    Obj.repr(
# 397 "parser.mly"
                  ( JVarArgs )
# 1121 "parser.ml"
               : 'access_item))
; (fun __caml_parser_env ->
    Obj.repr(
# 398 "parser.mly"
                 ( JStrict )
# 1127 "parser.ml"
               : 'access_item))
; (fun __caml_parser_env ->
    Obj.repr(
# 399 "parser.mly"
                    ( JSynthetic )
# 1133 "parser.ml"
               : 'access_item))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'classname) in
    Obj.repr(
# 403 "parser.mly"
                         ( TObject(_2,[]) )
# 1140 "parser.ml"
               : 'super_spec))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'implements_list) in
    Obj.repr(
# 407 "parser.mly"
                    ( _1 )
# 1147 "parser.ml"
               : 'implements))
; (fun __caml_parser_env ->
    Obj.repr(
# 408 "parser.mly"
                ( [] )
# 1153 "parser.ml"
               : 'implements))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'implements_spec) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'implements_list) in
    Obj.repr(
# 411 "parser.mly"
                                      ( _1::_2 )
# 1161 "parser.ml"
               : 'implements_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'implements_spec) in
    Obj.repr(
# 412 "parser.mly"
                      ( [_1] )
# 1168 "parser.ml"
               : 'implements_list))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'classname) in
    Obj.repr(
# 415 "parser.mly"
                                  ( TObject(_2,[]) )
# 1175 "parser.ml"
               : 'implements_spec))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'ann_cls_list) in
    Obj.repr(
# 420 "parser.mly"
                 ( [] )
# 1182 "parser.ml"
               : 'annotations))
; (fun __caml_parser_env ->
    Obj.repr(
# 421 "parser.mly"
                ( [] )
# 1188 "parser.ml"
               : 'annotations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'ann_cls_list) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'ann_cls_spec) in
    Obj.repr(
# 425 "parser.mly"
      ( _2::_1 )
# 1196 "parser.ml"
               : 'ann_cls_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'ann_cls_spec) in
    Obj.repr(
# 427 "parser.mly"
      ( [_1] )
# 1203 "parser.ml"
               : 'ann_cls_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'ann_cls_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'ann_arglist) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'endannotationsep) in
    Obj.repr(
# 431 "parser.mly"
        ( "" )
# 1212 "parser.ml"
               : 'ann_cls_spec))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'ann_clf_expr) in
    Obj.repr(
# 435 "parser.mly"
          ( () )
# 1219 "parser.ml"
               : 'ann_cls_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'endannotation) in
    Obj.repr(
# 438 "parser.mly"
                      ( () )
# 1226 "parser.ml"
               : 'endannotationsep))
; (fun __caml_parser_env ->
    Obj.repr(
# 441 "parser.mly"
                    ( () )
# 1232 "parser.ml"
               : 'endannotation))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'classname) in
    Obj.repr(
# 445 "parser.mly"
    ( () )
# 1239 "parser.ml"
               : 'ann_clf_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'classname) in
    Obj.repr(
# 447 "parser.mly"
    ( () )
# 1246 "parser.ml"
               : 'ann_clf_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'classname) in
    Obj.repr(
# 451 "parser.mly"
    ( () )
# 1253 "parser.ml"
               : 'ann_met_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'classname) in
    Obj.repr(
# 453 "parser.mly"
    ( () )
# 1260 "parser.ml"
               : 'ann_met_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : int) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'classname) in
    Obj.repr(
# 455 "parser.mly"
    ( () )
# 1268 "parser.ml"
               : 'ann_met_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : int) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'classname) in
    Obj.repr(
# 457 "parser.mly"
    ( () )
# 1276 "parser.ml"
               : 'ann_met_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'ann_arg_list) in
    Obj.repr(
# 460 "parser.mly"
                 ( [] )
# 1283 "parser.ml"
               : 'ann_arglist))
; (fun __caml_parser_env ->
    Obj.repr(
# 461 "parser.mly"
                ( [] )
# 1289 "parser.ml"
               : 'ann_arglist))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'ann_arg_list) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'ann_arg_spec) in
    Obj.repr(
# 465 "parser.mly"
      ( _2::_1 )
# 1297 "parser.ml"
               : 'ann_arg_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'ann_arg_spec) in
    Obj.repr(
# 467 "parser.mly"
      ( [_1] )
# 1304 "parser.ml"
               : 'ann_arg_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'ann_arg_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'ann_value_list) in
    Obj.repr(
# 471 "parser.mly"
        ( (_1,_3) )
# 1312 "parser.ml"
               : 'ann_arg_spec))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 475 "parser.mly"
          ( "" )
# 1320 "parser.ml"
               : 'ann_arg_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 477 "parser.mly"
          ( "" )
# 1329 "parser.ml"
               : 'ann_arg_expr))
; (fun __caml_parser_env ->
    Obj.repr(
# 481 "parser.mly"
    ( () )
# 1335 "parser.ml"
               : 'ann_def_spec))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'ann_value_items) in
    Obj.repr(
# 485 "parser.mly"
    ( _1 )
# 1342 "parser.ml"
               : 'ann_value_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'ann_ann_list) in
    Obj.repr(
# 487 "parser.mly"
    ( _1 )
# 1349 "parser.ml"
               : 'ann_value_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'ann_value_items) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'ann_value) in
    Obj.repr(
# 491 "parser.mly"
    ( _2::_1 )
# 1357 "parser.ml"
               : 'ann_value_items))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'ann_value) in
    Obj.repr(
# 493 "parser.mly"
    ( [_1] )
# 1364 "parser.ml"
               : 'ann_value_items))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'any_item) in
    Obj.repr(
# 497 "parser.mly"
      ( "" )
# 1371 "parser.ml"
               : 'ann_value))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'ann_ann_list) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'ann_ann_value) in
    Obj.repr(
# 500 "parser.mly"
                               ( _2::_1 )
# 1379 "parser.ml"
               : 'ann_ann_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'ann_ann_value) in
    Obj.repr(
# 501 "parser.mly"
                  ( [_1] )
# 1386 "parser.ml"
               : 'ann_ann_list))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ann_nest) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'ann_arglist) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'endannotationsep) in
    Obj.repr(
# 505 "parser.mly"
      ( "" )
# 1395 "parser.ml"
               : 'ann_ann_value))
; (fun __caml_parser_env ->
    Obj.repr(
# 508 "parser.mly"
            ( () )
# 1401 "parser.ml"
               : 'ann_nest))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'ann_def_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'ann_value_list) in
    Obj.repr(
# 512 "parser.mly"
    ( () )
# 1409 "parser.ml"
               : 'ann_def_val))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 516 "parser.mly"
      ( () )
# 1416 "parser.ml"
               : 'ann_def_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 518 "parser.mly"
      ( () )
# 1424 "parser.ml"
               : 'ann_def_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'debug_list) in
    Obj.repr(
# 522 "parser.mly"
               ( Some (String.concat " " (List.rev _1)) )
# 1431 "parser.ml"
               : 'debug_extension))
; (fun __caml_parser_env ->
    Obj.repr(
# 523 "parser.mly"
                ( None )
# 1437 "parser.ml"
               : 'debug_extension))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'debug_list) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'debug_spec) in
    Obj.repr(
# 527 "parser.mly"
      ( _2::_1 )
# 1445 "parser.ml"
               : 'debug_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'debug_spec) in
    Obj.repr(
# 529 "parser.mly"
      ( [_1] )
# 1452 "parser.ml"
               : 'debug_list))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    Obj.repr(
# 532 "parser.mly"
                       ( _2 )
# 1459 "parser.ml"
               : 'debug_spec))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : string) in
    Obj.repr(
# 537 "parser.mly"
    ( (*
      let (name, md) = split_method $3 in
      let (vts, ovt) = JParseSignature.parse_method_descriptor md in
      let ms = JBasics.make_ms name vts ovt in
      Some (!cn,Some (ms))
      *)
      None
    )
# 1473 "parser.ml"
               : 'enclosing_spec))
; (fun __caml_parser_env ->
    Obj.repr(
# 545 "parser.mly"
                  ( None )
# 1479 "parser.ml"
               : 'enclosing_spec))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'generic_list) in
    Obj.repr(
# 549 "parser.mly"
                 ( [] (*$1*) )
# 1486 "parser.ml"
               : 'generic_attributes))
; (fun __caml_parser_env ->
    Obj.repr(
# 550 "parser.mly"
                ( [] )
# 1492 "parser.ml"
               : 'generic_attributes))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'generic_list) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'generic_spec) in
    Obj.repr(
# 553 "parser.mly"
                                ( _2::_1 )
# 1500 "parser.ml"
               : 'generic_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'generic_spec) in
    Obj.repr(
# 554 "parser.mly"
                   ( [_1] )
# 1507 "parser.ml"
               : 'generic_list))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'generic_expr) in
    Obj.repr(
# 557 "parser.mly"
                                    ( _2 )
# 1514 "parser.ml"
               : 'generic_spec))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 560 "parser.mly"
             ( (_1,_2) )
# 1522 "parser.ml"
               : 'generic_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'field_list) in
    Obj.repr(
# 564 "parser.mly"
               ( _1 )
# 1529 "parser.ml"
               : 'fields))
; (fun __caml_parser_env ->
    Obj.repr(
# 565 "parser.mly"
    ( [] )
# 1535 "parser.ml"
               : 'fields))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'field_spec) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'field_list) in
    Obj.repr(
# 568 "parser.mly"
                            ( _1::_2 )
# 1543 "parser.ml"
               : 'field_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'field_spec) in
    Obj.repr(
# 569 "parser.mly"
                 ( [_1] )
# 1550 "parser.ml"
               : 'field_list))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 6 : 'access) in
    let _3 = (Parsing.peek_val __caml_parser_env 5 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 4 : string) in
    let _6 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _7 = (Parsing.peek_val __caml_parser_env 1 : 'optional_default) in
    Obj.repr(
# 573 "parser.mly"
        (
          (*
          let fs = JBasics.make_fs $3 (JParseSignature.parse_field_descriptor $4) in
          let f = {
            cf_signature = fs;
            cf_class_signature = JBasics.make_cfs !cn fs;
            cf_generic_signature = None;
            cf_access = cf_access $2;
            cf_static = List.mem `Static $2;
            cf_synthetic = List.mem `Synthetic $2;
            cf_enum = List.mem `Enum $2;
            cf_kind = if List.mem `Final $2 then Final else NotFinal;
            cf_value = None;
            cf_transient = false;
            cf_annotations = [];
            cf_other_flags = [];
            cf_attributes = {
              synthetic = false; deprecated = false; other = []
            }
          } in
          (fs,f)
          *)
          { JData.jf_name = "aa"; jf_kind = JData.JKField;
            jf_vmsignature = JData.TInt; jf_signature = JData.TInt;
            jf_throws = []; jf_types = []; jf_flags = [JData.JPublic];
            jf_attributes = []; jf_constant = None; jf_code = None
          }

        )
# 1589 "parser.ml"
               : 'field_spec))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'access) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'optional_default) in
    Obj.repr(
# 603 "parser.mly"
        (
          (*
          let fs = JBasics.make_fs $3 (JParseSignature.parse_field_descriptor $4) in
          let f = {
            cf_signature = fs;
            cf_class_signature = JBasics.make_cfs !cn fs;
            cf_generic_signature = None;
            cf_access = cf_access $2;
            cf_static = List.mem `Static $2;
            cf_synthetic = List.mem `Synthetic $2;
            cf_enum = List.mem `Enum $2;
            cf_kind = if List.mem `Final $2 then Final else NotFinal;
            cf_value = None;
            cf_transient = false;
            cf_annotations = [];
            cf_other_flags = [];
            cf_attributes = {
              synthetic = false; deprecated = false; other = []
            }
          } in
          (fs,f)
          *)
          { JData.jf_name = "aa"; jf_kind = JData.JKField;
            jf_vmsignature = JData.TInt; jf_signature = JData.TInt;
            jf_throws = []; jf_types = []; jf_flags = [JData.JPublic];
            jf_attributes = []; jf_constant = None; jf_code = None
          }
        )
# 1626 "parser.ml"
               : 'field_spec))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'field_start) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'field_exts) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'endfield) in
    Obj.repr(
# 632 "parser.mly"
        (
          { JData.jf_name = "aa"; jf_kind = JData.JKField;
            jf_vmsignature = JData.TInt; jf_signature = JData.TInt;
            jf_throws = []; jf_types = []; jf_flags = [JData.JPublic];
            jf_attributes = []; jf_constant = None; jf_code = None
          }
          (*let fs = JBasics.make_fs "" (JParseSignature.parse_field_descriptor $2) in
          let f = {
            cf_signature = fs;
            cf_class_signature = JBasics.make_cfs !cn fs;
            cf_generic_signature = None;
            cf_access = `Default;
            cf_static = false;
            cf_synthetic = false;
            cf_enum = false;
            cf_kind = NotFinal;
            cf_value = None;
            cf_transient = false;
            cf_annotations = [];
            cf_other_flags = [];
            cf_attributes = {
              synthetic = false; deprecated = false; other = []
            }
          } in
          (fs,f)
          *)
        )
# 1661 "parser.ml"
               : 'field_spec))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'item) in
    Obj.repr(
# 662 "parser.mly"
                  ( Some _2 )
# 1668 "parser.ml"
               : 'optional_default))
; (fun __caml_parser_env ->
    Obj.repr(
# 663 "parser.mly"
                      ( None )
# 1674 "parser.ml"
               : 'optional_default))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'access) in
    let _2 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'optional_default) in
    Obj.repr(
# 668 "parser.mly"
          ( "" )
# 1684 "parser.ml"
               : 'field_start))
; (fun __caml_parser_env ->
    Obj.repr(
# 672 "parser.mly"
          ( () )
# 1690 "parser.ml"
               : 'endfield))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'field_ext_list) in
    Obj.repr(
# 675 "parser.mly"
                         ( _1 )
# 1697 "parser.ml"
               : 'field_exts))
; (fun __caml_parser_env ->
    Obj.repr(
# 676 "parser.mly"
                      ( [] )
# 1703 "parser.ml"
               : 'field_exts))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'field_ext_list) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'field_ext_expr) in
    Obj.repr(
# 679 "parser.mly"
                                          ( _2::_1 )
# 1711 "parser.ml"
               : 'field_ext_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'field_ext_expr) in
    Obj.repr(
# 680 "parser.mly"
                           ( [_1] )
# 1718 "parser.ml"
               : 'field_ext_list))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'signature_expr) in
    Obj.repr(
# 684 "parser.mly"
              ( "" )
# 1725 "parser.ml"
               : 'field_ext_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'generic_expr) in
    Obj.repr(
# 686 "parser.mly"
              ( "" )
# 1732 "parser.ml"
               : 'field_ext_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'deprecated_expr) in
    Obj.repr(
# 688 "parser.mly"
              ( "" )
# 1739 "parser.ml"
               : 'field_ext_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ann_clf_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'ann_arglist) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'endannotationsep) in
    Obj.repr(
# 690 "parser.mly"
              ( "" )
# 1748 "parser.ml"
               : 'field_ext_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in
    Obj.repr(
# 695 "parser.mly"
    ( () )
# 1755 "parser.ml"
               : 'item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 697 "parser.mly"
    ( () )
# 1762 "parser.ml"
               : 'item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 699 "parser.mly"
    ( () )
# 1769 "parser.ml"
               : 'item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 704 "parser.mly"
    ( () )
# 1776 "parser.ml"
               : 'any_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'item) in
    Obj.repr(
# 706 "parser.mly"
    ( () )
# 1783 "parser.ml"
               : 'any_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'inner_list) in
    Obj.repr(
# 710 "parser.mly"
               ( debug "inners@."; [] (*List.rev $1*) )
# 1790 "parser.ml"
               : 'inners))
; (fun __caml_parser_env ->
    Obj.repr(
# 711 "parser.mly"
                ( [] )
# 1796 "parser.ml"
               : 'inners))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'inner_list) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'inner_spec) in
    Obj.repr(
# 714 "parser.mly"
                            ( _2::_1 )
# 1804 "parser.ml"
               : 'inner_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'inner_spec) in
    Obj.repr(
# 715 "parser.mly"
                 ( [_1] )
# 1811 "parser.ml"
               : 'inner_list))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'access) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'inner_name) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'inner_inner) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'inner_outer) in
    Obj.repr(
# 719 "parser.mly"
        (
          ""
          (*
          {
            ic_class_name = $5;
            ic_outer_class_name = $6;
            ic_source_name = $4;
            ic_access = cf_access $3;
            ic_static = List.mem `Static $3;
            ic_final = List.mem `Final $3;
            ic_synthetic = List.mem `Synthetic $3;
            ic_annotation = List.mem `Annotation $3;
            ic_enum = List.mem `Enum $3;
            ic_other_flags = []; *)(* TODO *)(*
            ic_type = `ConcreteClass *)(* TODO `Abstract *)(*
          }
          *)
        )
# 1838 "parser.ml"
               : 'inner_spec))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'access) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'inner_name) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'inner_inner) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'inner_outer) in
    Obj.repr(
# 738 "parser.mly"
        (
          ""
          (*
          {
            ic_class_name = $5;
            ic_outer_class_name = $6;
            ic_source_name = $4;
            ic_access = cf_access $3;
            ic_static = List.mem `Static $3;
            ic_final = List.mem `Final $3;
            ic_synthetic = List.mem `Synthetic $3;
            ic_annotation = List.mem `Annotation $3;
            ic_enum = List.mem `Enum $3;
            ic_other_flags = []; *)(* TODO *)(*
            ic_type = `Interface
          }
          *)
        )
# 1865 "parser.ml"
               : 'inner_spec))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 758 "parser.mly"
               ( Some _1 )
# 1872 "parser.ml"
               : 'inner_name))
; (fun __caml_parser_env ->
    Obj.repr(
# 759 "parser.mly"
                      ( None )
# 1878 "parser.ml"
               : 'inner_name))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'classname) in
    Obj.repr(
# 762 "parser.mly"
                          ( Some _2 )
# 1885 "parser.ml"
               : 'inner_inner))
; (fun __caml_parser_env ->
    Obj.repr(
# 763 "parser.mly"
                      ( None )
# 1891 "parser.ml"
               : 'inner_inner))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'classname) in
    Obj.repr(
# 766 "parser.mly"
                          ( Some _2 )
# 1898 "parser.ml"
               : 'inner_outer))
; (fun __caml_parser_env ->
    Obj.repr(
# 767 "parser.mly"
                      ( None )
# 1904 "parser.ml"
               : 'inner_outer))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'method_list) in
    Obj.repr(
# 771 "parser.mly"
                ( List.rev _1 )
# 1911 "parser.ml"
               : 'methods))
; (fun __caml_parser_env ->
    Obj.repr(
# 772 "parser.mly"
                ( [] )
# 1917 "parser.ml"
               : 'methods))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'method_spec) in
    Obj.repr(
# 775 "parser.mly"
                  ( [_1] )
# 1924 "parser.ml"
               : 'method_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'method_list) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'method_spec) in
    Obj.repr(
# 776 "parser.mly"
                              ( _2::_1 )
# 1932 "parser.ml"
               : 'method_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'defmethod) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'statements) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'endmethod) in
    Obj.repr(
# 780 "parser.mly"
        (
          let(access,(name,md)) = _1 in
          let code,lines,excs,throws = mkcode (List.rev _2) in
          let jmethod = {
            JCode.max_stack = !limit_stack;
            max_locals = !limit_locals;
            code = code;
            exc_tbl = excs;
            (*c_line_number_table = lines; TODO *)
            (*c_local_variable_table = None;  TODO *)
            (*c_local_variable_type_table = None;  TODO *)
            (*c_stack_map_midp = None;  TODO *)
            (*c_stack_map_java6 = None;  TODO *)
            attributes = []; (* TODO *)
          }
          in
          JCodeWriter.encode_code !ctx jmethod;
          let code = IO.close_out !ctx.ch in
          !ctx.ch <- !back_ch;
          Format.printf "name = %S code = %S@."  name code;
          (*
          let m = ConcreteMethod {
            cm_signature = ms;
            cm_class_method_signature = JBasics.make_cms !cn ms;
            cm_static = List.mem `Static access;
            cm_final = List.mem `Final access;
            cm_synchronized = List.mem `Synchronized access;
            cm_strict = List.mem `Strict access;
            cm_access = cf_access access;
            cm_generic_signature = None; *)(* TODO *)(*
            cm_bridge = List.mem `Bridge access;
            cm_varargs = List.mem `Varargs access;
            cm_synthetic = List.mem `Synthetic access;
            cm_other_flags = []; *)(* TODO *)(*
            cm_exceptions = throws; *)(* TODO *)(*
            cm_attributes = { synthetic = false; deprecated = false; other = [] };  *)(* TODO *)(*
            cm_annotations = { ma_global = []; ma_parameters = [] }; *)(* TODO *)(*
            cm_implementation = Java (lazy jmethod)
          } in (ms,m)
          *)
          { JData.jf_name = name; jf_kind = JData.JKMethod;
                jf_vmsignature = (JData.TMethod
                                    ([JData.TArray (
                                        JData.TObject (
                                          (["java"; "lang"], "String"), [
                                          ]), None)], None));
                jf_signature = (JData.TMethod
                                  ([JData.TArray (
                                      JData.TObject (
                                        (["java"; "lang"], "String"), [
                                        ]), None)], None)); jf_throws = [
                ]; jf_types = []; jf_flags = [JData.JStatic; JData.JPublic];
                jf_attributes = [JData.AttrUnknown ("Code", code)];
                jf_constant = None; jf_code = None
          }
        )
# 1996 "parser.ml"
               : 'method_spec))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'defmethod) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'endmethod) in
    Obj.repr(
# 837 "parser.mly"
        (
          (*
          let(access,ms) = $1 in
          let code =[||] in
          let jmethod = {
            JCode.c_max_stack = 0;
            c_max_locals = 0;
            c_code = code;
            c_exc_tbl = [];
            c_line_number_table = None;
            c_local_variable_table = None;
            c_local_variable_type_table = None;
            c_stack_map_midp = None;
            c_stack_map_java6 = None;
            c_attributes = []
          }
          in
          let m = ConcreteMethod {
            cm_signature = ms;
            cm_class_method_signature = JBasics.make_cms !cn ms;
            cm_static = List.mem `Static access;
            cm_final = List.mem `Final access;
            cm_synchronized = List.mem `Synchronized access;
            cm_strict = List.mem `Strict access;
            cm_access = cf_access access;
            cm_generic_signature = None;
            cm_bridge = List.mem `Bridge access;
            cm_varargs = List.mem `Varargs access;
            cm_synthetic = List.mem `Synthetic access;
            cm_other_flags = [];
            cm_exceptions = [];
            cm_attributes = { synthetic = false; deprecated = false; other = [] };
            cm_annotations = { ma_global = []; ma_parameters = [] };
            cm_implementation = Java (lazy jmethod)
          } in (ms,m)*)
          { JData.jf_name = "main"; jf_kind = JData.JKMethod;
                jf_vmsignature = (JData.TMethod
                                    ([JData.TArray (
                                        JData.TObject (
                                          (["java"; "lang"], "String"), [
                                          ]), None)], None));
                jf_signature = (JData.TMethod
                                  ([JData.TArray (
                                      JData.TObject (
                                        (["java"; "lang"], "String"), [
                                        ]), None)], None)); jf_throws = [
                ]; jf_types = []; jf_flags = [JData.JStatic; JData.JPublic];
                jf_attributes = [JData.AttrUnknown ("Code",
                                   "\000\002\000\001\000\000\000\017?\000\002\018\003?\000\004?\000\005Y?\000\006W?\000\000\000\001\000\016\000\000\000\014\000\003\000\000\000\004\000\b\000\005\000\016\000\006")];
                jf_constant = None; jf_code = None
          }

        )
# 2056 "parser.ml"
               : 'method_spec))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'access) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : string) in
    Obj.repr(
# 893 "parser.mly"
          (
            init_method();
            let (name, md) = split_method _3 in
            (*
            let (vts, ovt) = JParseSignature.parse_method_descriptor md in
            let ms = JBasics.make_ms name vts ovt
            in ($2, ms)
            *)
            (_2,(name,md))
          )
# 2073 "parser.ml"
               : 'defmethod))
; (fun __caml_parser_env ->
    Obj.repr(
# 905 "parser.mly"
                          ( () )
# 2079 "parser.ml"
               : 'endmethod))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'statements) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'statement) in
    Obj.repr(
# 909 "parser.mly"
                               ( _2::_1 )
# 2087 "parser.ml"
               : 'statements))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'statement) in
    Obj.repr(
# 910 "parser.mly"
                    ( [_1] )
# 2094 "parser.ml"
               : 'statements))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'stmnt) in
    Obj.repr(
# 913 "parser.mly"
                      ( _1 )
# 2101 "parser.ml"
               : 'statement))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'instruction) in
    Obj.repr(
# 916 "parser.mly"
                          ( _1 )
# 2108 "parser.ml"
               : 'stmnt))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'directive) in
    Obj.repr(
# 917 "parser.mly"
                        ( _1 )
# 2115 "parser.ml"
               : 'stmnt))
; (fun __caml_parser_env ->
    Obj.repr(
# 918 "parser.mly"
                    ( add 0 JCode.OpInvalid )
# 2121 "parser.ml"
               : 'stmnt))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'label) in
    Obj.repr(
# 919 "parser.mly"
                    ( _1 )
# 2128 "parser.ml"
               : 'stmnt))
; (fun __caml_parser_env ->
    Obj.repr(
# 920 "parser.mly"
                          ( add 0 JCode.OpInvalid )
# 2134 "parser.ml"
               : 'stmnt))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    Obj.repr(
# 924 "parser.mly"
                           (
                addlabel _1 !pos;
                add 0 JCode.OpInvalid
               )
# 2144 "parser.ml"
               : 'label))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : int) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'instruction) in
    Obj.repr(
# 928 "parser.mly"
                                      (
                let (pos, _) = _3 in
                addlabel (string_of_int _1) pos;
                _3
              )
# 2156 "parser.ml"
               : 'label))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'var_expr) in
    Obj.repr(
# 937 "parser.mly"
                (
                  failwith "TODO: .var"
                )
# 2165 "parser.ml"
               : 'directive))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'limit_expr) in
    Obj.repr(
# 940 "parser.mly"
                                  ( add 0 JCode.OpInvalid )
# 2172 "parser.ml"
               : 'directive))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'line_expr) in
    Obj.repr(
# 941 "parser.mly"
                                ( add 0 JCode.OpInvalid )
# 2179 "parser.ml"
               : 'directive))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'throws_expr) in
    Obj.repr(
# 942 "parser.mly"
                                    ( add 0 JCode.OpInvalid )
# 2186 "parser.ml"
               : 'directive))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'catch_expr) in
    Obj.repr(
# 943 "parser.mly"
                                  ( add 0 JCode.OpInvalid )
# 2193 "parser.ml"
               : 'directive))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'set_expr) in
    Obj.repr(
# 945 "parser.mly"
                (
                  failwith "TODO: .set"
                )
# 2202 "parser.ml"
               : 'directive))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'signature_expr) in
    Obj.repr(
# 949 "parser.mly"
                (
                  failwith "TODO: .signature"
                )
# 2211 "parser.ml"
               : 'directive))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'generic_expr) in
    Obj.repr(
# 953 "parser.mly"
                (
                  failwith "TODO: .attribute"
                )
# 2220 "parser.ml"
               : 'directive))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'deprecated_expr) in
    Obj.repr(
# 957 "parser.mly"
                (
                  failwith "TODO: .deprected"
                )
# 2229 "parser.ml"
               : 'directive))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ann_met_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'ann_arglist) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'endannotation) in
    Obj.repr(
# 961 "parser.mly"
                (
                  failwith "TODO: .annotation"
                )
# 2240 "parser.ml"
               : 'directive))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ann_def_spec) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'ann_def_val) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'endannotation) in
    Obj.repr(
# 965 "parser.mly"
                (
                  failwith "TODO: .annotation"
                )
# 2251 "parser.ml"
               : 'directive))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'stackmap) in
    Obj.repr(
# 969 "parser.mly"
                (
                  failwith "TODO: .stack"
                )
# 2260 "parser.ml"
               : 'directive))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 8 : int) in
    let _3 = (Parsing.peek_val __caml_parser_env 6 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 5 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 4 : 'optional_signature) in
    let _7 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _9 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 979 "parser.mly"
                  ( ()  (* TODO *))
# 2272 "parser.ml"
               : 'var_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : int) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'optional_signature) in
    Obj.repr(
# 981 "parser.mly"
                  ( ()  (* TODO *))
# 2282 "parser.ml"
               : 'var_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 8 : int) in
    let _3 = (Parsing.peek_val __caml_parser_env 6 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 5 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 4 : 'optional_signature) in
    let _7 = (Parsing.peek_val __caml_parser_env 2 : int) in
    let _9 = (Parsing.peek_val __caml_parser_env 0 : int) in
    Obj.repr(
# 983 "parser.mly"
                  ( ()  (* TODO *))
# 2294 "parser.ml"
               : 'var_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 987 "parser.mly"
                                  ( Some _2 )
# 2301 "parser.ml"
               : 'optional_signature))
; (fun __caml_parser_env ->
    Obj.repr(
# 988 "parser.mly"
                                ( None )
# 2307 "parser.ml"
               : 'optional_signature))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : int) in
    Obj.repr(
# 995 "parser.mly"
                             ( limit_locals := _2 )
# 2314 "parser.ml"
               : 'limit_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : int) in
    Obj.repr(
# 996 "parser.mly"
                            ( limit_stack := _2 )
# 2321 "parser.ml"
               : 'limit_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : int) in
    Obj.repr(
# 997 "parser.mly"
                           ( () )
# 2329 "parser.ml"
               : 'limit_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in
    Obj.repr(
# 1001 "parser.mly"
                      ( lines := (!pos, _1) :: !lines )
# 2336 "parser.ml"
               : 'line_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'classname) in
    Obj.repr(
# 1005 "parser.mly"
                            ( throws := _1 :: !throws )
# 2343 "parser.ml"
               : 'throws_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'classname) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1010 "parser.mly"
                  (
                    excs := {
                      JCode.e_start = label2int _3;
                      e_end = label2int _5;
                      e_handler = label2int _7;
                      e_catch_type = Some _1
                    } :: !excs
                  )
# 2360 "parser.ml"
               : 'catch_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'classname) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : int) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : int) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : int) in
    Obj.repr(
# 1019 "parser.mly"
                  (
                    excs := {
                      JCode.e_start = _3;
                      e_end = _5;
                      e_handler = _7;
                      e_catch_type = Some _1
                    } :: !excs
                  )
# 2377 "parser.ml"
               : 'catch_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'any_item) in
    Obj.repr(
# 1030 "parser.mly"
                                ( () )
# 2385 "parser.ml"
               : 'set_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'defstack) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'stack_map_frame_desc) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'endstack) in
    Obj.repr(
# 1038 "parser.mly"
                  ( () )
# 2394 "parser.ml"
               : 'stackmap))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'defstack_same) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'stack_map_frame_desc) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'endstack) in
    Obj.repr(
# 1040 "parser.mly"
                  ( () )
# 2403 "parser.ml"
               : 'stackmap))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'defstack_same_expr) in
    Obj.repr(
# 1044 "parser.mly"
                    ( () )
# 2410 "parser.ml"
               : 'defstack_same))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in
    Obj.repr(
# 1048 "parser.mly"
                    ( () )
# 2417 "parser.ml"
               : 'defstack_same_expr))
; (fun __caml_parser_env ->
    Obj.repr(
# 1050 "parser.mly"
                    ( () )
# 2423 "parser.ml"
               : 'defstack_same_expr))
; (fun __caml_parser_env ->
    Obj.repr(
# 1053 "parser.mly"
                        ( () )
# 2429 "parser.ml"
               : 'defstack))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'stack_offset_def) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'stack_items) in
    Obj.repr(
# 1057 "parser.mly"
                    ( () )
# 2437 "parser.ml"
               : 'stack_map_frame_desc))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in
    Obj.repr(
# 1061 "parser.mly"
                    ( () )
# 2444 "parser.ml"
               : 'stack_offset_def))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    Obj.repr(
# 1063 "parser.mly"
                    ( () )
# 2451 "parser.ml"
               : 'stack_offset_def))
; (fun __caml_parser_env ->
    Obj.repr(
# 1065 "parser.mly"
                    ( () )
# 2457 "parser.ml"
               : 'stack_offset_def))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'stack_items) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'stack_item) in
    Obj.repr(
# 1068 "parser.mly"
                                           ( _2::_1 )
# 2465 "parser.ml"
               : 'stack_items))
; (fun __caml_parser_env ->
    Obj.repr(
# 1069 "parser.mly"
                                  ( [] )
# 2471 "parser.ml"
               : 'stack_items))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'stack_item_expr) in
    Obj.repr(
# 1072 "parser.mly"
                                        ( _1 )
# 2478 "parser.ml"
               : 'stack_item))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1076 "parser.mly"
                    ( "" )
# 2485 "parser.ml"
               : 'stack_item_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1078 "parser.mly"
                    ( "" )
# 2493 "parser.ml"
               : 'stack_item_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : int) in
    Obj.repr(
# 1080 "parser.mly"
                    ( "" )
# 2501 "parser.ml"
               : 'stack_item_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1082 "parser.mly"
                    ( "" )
# 2508 "parser.ml"
               : 'stack_item_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1084 "parser.mly"
                    ( "" )
# 2516 "parser.ml"
               : 'stack_item_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : int) in
    Obj.repr(
# 1086 "parser.mly"
                    ( "" )
# 2524 "parser.ml"
               : 'stack_item_expr))
; (fun __caml_parser_env ->
    Obj.repr(
# 1089 "parser.mly"
                               ( () )
# 2530 "parser.ml"
               : 'endstack))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_instruction) in
    Obj.repr(
# 1092 "parser.mly"
                                   ( _1 )
# 2537 "parser.ml"
               : 'instruction))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'complex_instruction) in
    Obj.repr(
# 1093 "parser.mly"
                                    ( _1 )
# 2544 "parser.ml"
               : 'instruction))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string * string) in
    Obj.repr(
# 1098 "parser.mly"
                       (
                  match (fst _1) with
                  (* A *)
                  | "aaload" -> add 1 (JCode.OpAALoad)
                  | "aastore" -> add 1 (JCode.OpAAStore)
                  | "aconst_null" -> add 1 (JCode.OpAConstNull)
                  | "aload_0" -> add 1 (JCode.OpALoad 0)
                  | "aload_1" -> add 1 (JCode.OpALoad 1)
                  | "aload_2" -> add 1 (JCode.OpALoad 2)
                  | "aload_3" -> add 1 (JCode.OpALoad 3)
                  | "areturn" -> add 1 (JCode.OpAReturn)
                  | "arraylength" -> add 1 (JCode.OpArrayLength)
                  | "astore_0" -> add 1 (JCode.OpAStore 0)
                  | "astore_1" -> add 1 (JCode.OpAStore 1)
                  | "astore_2" -> add 1 (JCode.OpAStore 2)
                  | "astore_3" -> add 1 (JCode.OpAStore 3)
                  | "athrow" -> add 1 (JCode.OpThrow)
                  (* B *)
                  | "baload" ->add 1 (JCode.OpBALoad)
                  | "bastore" -> add 1 (JCode.OpBAStore)
                  | "breakpoint" -> add 1 (JCode.OpBreakpoint)
                  (* C *)
                  | "caload" ->add 1 (JCode.OpCALoad)
                  | "castore" -> add 1 (JCode.OpCAStore)
                  (* D *)
                  | "d2f" -> add 1 (JCode.OpD2F)
                  | "d2i" -> add 1 (JCode.OpD2I)
                  | "d2l" -> add 1 (JCode.OpD2L)
                  | "dadd" -> add 1 (JCode.OpAdd `Double)
                  | "daload" ->add 1 (JCode.OpArrayLoad `Double)
                  | "dastore" -> add 1 (JCode.OpArrayStore `Double)
                  | "dcmpg" -> add 1 (JCode.OpDCmpG)
                  | "dcmpl" -> add 1 (JCode.OpDCmpL)
                  | "dconst_0" -> add 1 (JCode.OpDConst( (0.)))
                  | "dconst_1" -> add 1 (JCode.OpDConst( (1.)))
                  | "ddiv" -> add 1 (JCode.OpDiv `Double)
                  | "dload_0" -> add 1 (JCode.OpLoad (`Double, 0))
                  | "dload_1" -> add 1 (JCode.OpLoad (`Double, 1))
                  | "dload_2" -> add 1 (JCode.OpLoad (`Double, 2))
                  | "dload_3" -> add 1 (JCode.OpLoad (`Double, 3))
                  | "dmul" -> add 1 (JCode.OpMult `Double)
                  | "dneg" -> add 1 (JCode.OpNeg `Double)
                  | "drem" -> add 1 (JCode.OpRem `Double)
                  | "dreturn" -> add 1 (JCode.OpReturn `Double)
                  | "dstore_0" -> add 1 (JCode.OpStore (`Double, 0))
                  | "dstore_1" -> add 1 (JCode.OpStore (`Double, 1))
                  | "dstore_2" -> add 1 (JCode.OpStore (`Double, 2))
                  | "dstore_3" -> add 1 (JCode.OpStore (`Double, 3))
                  | "dsub" -> add 1 (JCode.OpSub `Double)
                  | "dup" -> add 1 (JCode.OpDup)
                  | "dup2" -> add 1 (JCode.OpDup2)
                  | "dup2_x1" -> add 1 (JCode.OpDup2X1)
                  | "dup2_x2" -> add 1 (JCode.OpDup2X2)
                  | "dup_x1" -> add 1 (JCode.OpDupX1)
                  | "dup_x2" -> add 1 (JCode.OpDupX2)
                  (* F *)
                  | "f2i" -> add 1 (JCode.OpF2I)
                  | "f2l" -> add 1 (JCode.OpF2L)
                  | "f2d" -> add 1 (JCode.OpF2D)
                  | "fadd" -> add 1 (JCode.OpAdd `Float)
                  | "faload" ->add 1 (JCode.OpArrayLoad `Float)
                  | "fastore" -> add 1 (JCode.OpArrayStore `Float)
                  | "fcmpg" -> add 1 (JCode.OpFCmpG)
                  | "fcmpl" -> add 1 (JCode.OpFCmpL)
                  | "fconst_0" -> add 1(JCode.OpFConst( (0.)))
                  | "fconst_1" -> add 1(JCode.OpFConst( (1.)))
                  | "fconst_2" -> add 1(JCode.OpFConst( (2.)))
                  | "fdiv" -> add 1 (JCode.OpDiv `Float)
                  | "fload_0" -> add 1 (JCode.OpLoad (`Float, 0))
                  | "fload_1" -> add 1 (JCode.OpLoad (`Float, 1))
                  | "fload_2" -> add 1 (JCode.OpLoad (`Float, 2))
                  | "fload_3" -> add 1 (JCode.OpLoad (`Float, 3))
                  | "fmul" -> add 1 (JCode.OpMult `Float)
                  | "fneg" -> add 1 (JCode.OpNeg `Float)
                  | "frem" -> add 1 (JCode.OpRem `Float)
                  | "freturn" -> add 1 (JCode.OpReturn `Float)
                  | "fstore_0" -> add 1 (JCode.OpStore (`Float, 0))
                  | "fstore_1" -> add 1 (JCode.OpStore (`Float, 1))
                  | "fstore_2" -> add 1 (JCode.OpStore (`Float, 2))
                  | "fstore_3" -> add 1 (JCode.OpStore (`Float, 3))
                  | "fsub" -> add 1 (JCode.OpSub `Float)
                  (* I *)
                  | "i2f" -> add 1 (JCode.OpI2F)
                  | "i2d" -> add 1 (JCode.OpI2D)
                  | "i2l" -> add 1 (JCode.OpI2L)
                  | "iadd" -> add 1 (JCode.OpAdd `Int2Bool)
                  | "iaload" -> add 1 (JCode.OpArrayLoad `Int)
                  | "iand" -> add 1 (JCode.OpIAnd)
                  | "iastore" -> add 1 (JCode.OpArrayStore `Int)
                  | "iconst_0" -> add 1 (JCode.OpIConst( (0l)))
                  | "iconst_1" -> add 1 (JCode.OpIConst( (1l)))
                  | "iconst_2" -> add 1 (JCode.OpIConst( (2l)))
                  | "iconst_3" -> add 1 (JCode.OpIConst( (3l)))
                  | "iconst_4" -> add 1 (JCode.OpIConst( (4l)))
                  | "iconst_5" -> add 1 (JCode.OpIConst( (5l)))
                  | "iconst_m1" -> add 1 (JCode.OpIConst( (-1l)))
                  | "idiv" -> add 1 (JCode.OpDiv `Int2Bool)
                  | "iload_0" -> add 1 (JCode.OpLoad (`Int2Bool, 0))
                  | "iload_1" -> add 1 (JCode.OpLoad (`Int2Bool, 1))
                  | "iload_2" -> add 1 (JCode.OpLoad (`Int2Bool, 2))
                  | "iload_3" -> add 1 (JCode.OpLoad (`Int2Bool, 3))
                  | "imul" -> add 1 (JCode.OpMult `Int2Bool)
                  | "ineg" -> add 1 (JCode.OpNeg `Int2Bool)
                  | "int2byte" -> add 1 (JCode.OpI2B)
                  | "int2char" -> add 1 (JCode.OpI2C)
                  | "int2short" -> add 1 (JCode.OpI2S)
                  (*
                  | "invokedynamic", "method" -> add 1 ()
                  *)
                  | "ior" -> add 1 (JCode.OpIOr)
                  | "irem" -> add 1 (JCode.OpRem `Int2Bool)
                  | "ireturn" -> add 1 (JCode.OpReturn `Int2Bool)
                  | "ishl" -> add 1 (JCode.OpIShl)
                  | "ishr" -> add 1 (JCode.OpIShr)
                  | "istore_0" -> add 1 (JCode.OpStore (`Int2Bool, 0))
                  | "istore_1" -> add 1 (JCode.OpStore (`Int2Bool, 1))
                  | "istore_2" -> add 1 (JCode.OpStore (`Int2Bool, 2))
                  | "istore_3" -> add 1 (JCode.OpStore (`Int2Bool, 3))
                  | "isub" -> add 1 (JCode.OpSub `Int2Bool)
                  | "iushr" -> add 1 (JCode.OpIUShr)
                  | "ixor" -> add 1 (JCode.OpIXor)
                  (* L *)
                  | "l2f" -> add 1 (JCode.OpL2F)
                  | "l2d" -> add 1 (JCode.OpL2D)
                  | "l2i" -> add 1 (JCode.OpL2I)
                  | "ladd" -> add 1 (JCode.OpAdd `Long)
                  | "laload" ->add 1 (JCode.OpArrayLoad `Long)
                  | "land" -> add 1 (JCode.OpLAnd)
                  | "lastore" -> add 1 (JCode.OpArrayStore `Long)
                  | "lcmp" -> add 1 (JCode.OpLCmp)
                  | "lconst_0" -> add 1 (JCode.OpLConst( (Int64.of_int 0)))
                  | "lconst_1" -> add 1 (JCode.OpLConst( (Int64.of_int 1)))
                  | "ldiv" -> add 1 (JCode.OpDiv `Long)
                  | "lload_0" -> add 1 (JCode.OpLoad (`Long, 0))
                  | "lload_1" -> add 1 (JCode.OpLoad (`Long, 1))
                  | "lload_2" -> add 1 (JCode.OpLoad (`Long, 2))
                  | "lload_3" -> add 1 (JCode.OpLoad (`Long, 3))
                  | "lmul" -> add 1 (JCode.OpMult `Long)
                  | "lneg" -> add 1 (JCode.OpNeg `Long)
                  | "lor" -> add 1 (JCode.OpLOr)
                  | "lrem" -> add 1 (JCode.OpRem `Long)
                  | "lreturn" -> add 1 (JCode.OpReturn `Long)
                  | "lshl" -> add 1 (JCode.OpLShl)
                  | "lshr" -> add 1 (JCode.OpLShr)
                  | "lstore_0" -> add 1 (JCode.OpStore (`Long, 0))
                  | "lstore_1" -> add 1 (JCode.OpStore (`Long, 1))
                  | "lstore_2" -> add 1 (JCode.OpStore (`Long, 2))
                  | "lstore_3" -> add 1 (JCode.OpStore (`Long, 3))
                  | "lsub" -> add 1 (JCode.OpSub `Long)
                  | "lushr" -> add 1 (JCode.OpLUShr)
                  | "lxor" -> add 1 (JCode.OpLXor)
                  (* M *)
                  | "monitorenter" -> add 1 (JCode.OpMonitorEnter)
                  | "monitorexit" -> add 1 (JCode.OpMonitorExit)
                  (* N *)
                  | "nop" -> add 1 (JCode.OpNop)
                  (* P *)
                  | "pop" -> add 1 (JCode.OpPop)
                  | "pop2" -> add 1 (JCode.OpPop2)
                  (* R *)
                  | "return" -> add 1 (JCode.OpReturnVoid)
                  (* S *)
                  | "saload" -> add 1 (JCode.OpSALoad)
                  | "sastore" -> add 1 (JCode.OpSAStore)
                  | "swap" -> add 1 (JCode.OpSwap)
                  | a -> Printf.printf "Inst(%S, %S)@." a (snd _1); assert false
                )
# 2717 "parser.ml"
               : 'simple_instruction))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : string * string) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : int) in
    Obj.repr(
# 1265 "parser.mly"
                               (
                  match(fst _1,snd _1, _2,_3)with
                  | "iinc", "ii", i1, i2 -> add 6 (JCode.OpIInc (i1, i2))
                  | "iinc", "Ii", i1, i2 -> add 6 (JCode.OpIInc (i1, i2))
                  | a,b,i1,i2 ->
                    Printf.printf "InstIntInt(%S, %S, %d, %d)@." a b i1 i2;
                    assert false
                )
# 2733 "parser.ml"
               : 'simple_instruction))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string * string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : int) in
    Obj.repr(
# 1273 "parser.mly"
                           (
                  match(fst _1,snd _1, _2)with
                  (* A *)
                  | "aload", _, 0 -> add 1 (JCode.OpALoad 0)
                  | "aload", _, 1 -> add 1 (JCode.OpALoad 1)
                  | "aload", _, 2 -> add 1 (JCode.OpALoad 2)
                  | "aload", _, 3 -> add 1 (JCode.OpALoad 3)
                  | "aload", "i", n -> add 2 (JCode.OpALoad n)
                  | "aload", "I", n -> add 3 (JCode.OpALoad n)
                  | "astore", _, 0 -> add 1 (JCode.OpAStore 0)
                  | "astore", _, 1 -> add 1 (JCode.OpAStore 1)
                  | "astore", _, 2 -> add 1 (JCode.OpAStore 2)
                  | "astore", _, 3 -> add 1 (JCode.OpAStore 3)
                  | "astore", "i", n -> add 2 (JCode.OpAStore n)
                  | "astore", "I", n -> add 3 (JCode.OpAStore n)
                  (* B *)
                  | "bipush", "i", n -> add 2 (JCode.OpBIPush(n))
                  (* D *)
                  | "dload", _, 0 -> add 1 (JCode.OpLoad (`Double, 0))
                  | "dload", _, 1 -> add 1 (JCode.OpLoad (`Double, 1))
                  | "dload", _, 2 -> add 1 (JCode.OpLoad (`Double, 2))
                  | "dload", _, 3 -> add 1 (JCode.OpLoad (`Double, 3))
                  | "dload", "i", i -> add 2 (JCode.OpLoad (`Double, i))
                  | "dload", "I", n -> add 3 (JCode.OpLoad (`Double, n))
                  | "dstore", _, 0 -> add 1 (JCode.OpStore (`Double, 0))
                  | "dstore", _, 1 -> add 1 (JCode.OpStore (`Double, 1))
                  | "dstore", _, 2 -> add 1 (JCode.OpStore (`Double, 2))
                  | "dstore", _, 3 -> add 1 (JCode.OpStore (`Double, 3))
                  | "dstore", "i", i -> add 2 (JCode.OpStore (`Double, i))
                  | "dstore", "I", n -> add 3 (JCode.OpStore (`Double, n))
                  (* F *)
                  | "fload", _, 0 -> add 1 (JCode.OpLoad (`Float, 0))
                  | "fload", _, 1 -> add 1 (JCode.OpLoad (`Float, 1))
                  | "fload", _, 2 -> add 1 (JCode.OpLoad (`Float, 2))
                  | "fload", _, 3 -> add 1 (JCode.OpLoad (`Float, 3))
                  | "fload", "i", i -> add 2 (JCode.OpLoad (`Float, i))
                  | "fload", "I", n -> add 3 (JCode.OpLoad (`Float, n))
                  | "fstore", _, 0 -> add 1 (JCode.OpStore (`Float, 0))
                  | "fstore", _, 1 -> add 1 (JCode.OpStore (`Float, 1))
                  | "fstore", _, 2 -> add 1 (JCode.OpStore (`Float, 2))
                  | "fstore", _, 3 -> add 1 (JCode.OpStore (`Float, 3))
                  | "fstore", "i", i -> add 2 (JCode.OpStore (`Float, i))
                  | "fstore", "I", n -> add 3 (JCode.OpStore (`Float, n))
                  (* G *)
                  | "goto", "label", n -> add 3 (JCode.OpGoto n)
                  | "goto_w", "label", n -> add 3 (JCode.OpGoto n)
                  (* I *)
                  | "if_acmpeq", "label", n -> add 3 (JCode.OpACmpEq n)
                  | "if_acmpne", "label", n -> add 3 (JCode.OpACmpNe n)
                  | "if_icmpeq", "label", n -> add 3 (JCode.OpICmpEq n)
                  | "if_icmpge", "label", n -> add 3 (JCode.OpICmpGe n)
                  | "if_icmpgt", "label", n -> add 3 (JCode.OpICmpGt n)
                  | "if_icmple", "label", n -> add 3 (JCode.OpICmpLe n)
                  | "if_icmplt", "label", n -> add 3 (JCode.OpICmpLt n)
                  | "if_icmpne", "label", n -> add 3 (JCode.OpICmpNe n)
                  | "ifeq", "label", n -> add 3 (JCode.OpIfEq n)
                  | "ifge", "label", n -> add 3 (JCode.OpIfGe n)
                  | "ifgt", "label", n -> add 3 (JCode.OpIfGt n)
                  | "ifle", "label", n -> add 3 (JCode.OpIfLe n)
                  | "iflt", "label", n -> add 3 (JCode.OpIfLt n)
                  | "ifne", "label", n -> add 3 (JCode.OpIfNe n)
                  | "ifnonnull", "label", n -> add 3 (JCode.OpIfNonNull n)
                  | "ifnull", "label", n -> add 3 (JCode.OpIfNull n)
                  | "iload", _, 0 -> add 1 (JCode.OpLoad (`Int2Bool, 0))
                  | "iload", _, 1 -> add 1 (JCode.OpLoad (`Int2Bool, 1))
                  | "iload", _, 2 -> add 1 (JCode.OpLoad (`Int2Bool, 2))
                  | "iload", _, 3 -> add 1 (JCode.OpLoad (`Int2Bool, 3))
                  | "iload", "i", n -> add 2 (JCode.OpLoad (`Int2Bool, n))
                  | "iload", "I", n -> add 3 (JCode.OpLoad (`Int2Bool, n))
                  | "istore", _, 0 -> add 1 (JCode.OpStore (`Int2Bool, 0))
                  | "istore", _, 1 -> add 1 (JCode.OpStore (`Int2Bool, 1))
                  | "istore", _, 2 -> add 1 (JCode.OpStore (`Int2Bool, 2))
                  | "istore", _, 3 -> add 1 (JCode.OpStore (`Int2Bool, 3))
                  | "istore", "i", i -> add 2 (JCode.OpStore (`Int2Bool, i))
                  | "istore", "I", i -> add 3 (JCode.OpStore (`Int2Bool, i))
                  (* I *)
                  | "ldc", "constant", n -> add 2 (JCode.OpIConst( (Int32.of_int n)))
                  | "ldc2_w", "bigconstant", d -> add 3 (JCode.OpLConst( (Int64.of_int d)))
                  | "lload", _, 0 -> add 1 (JCode.OpLoad (`Long, 0))
                  | "lload", _, 1 -> add 1 (JCode.OpLoad (`Long, 1))
                  | "lload", _, 2 -> add 1 (JCode.OpLoad (`Long, 2))
                  | "lload", _, 3 -> add 1 (JCode.OpLoad (`Long, 3))
                  | "lload", "i", i -> add 2 (JCode.OpLoad (`Long, i)) 
                  | "lload", "I", n -> add 3 (JCode.OpLoad (`Long, n))
                  | "lstore", _, 0 -> add 1 (JCode.OpStore (`Long, 0))
                  | "lstore", _, 1 -> add 1 (JCode.OpStore (`Long, 1))
                  | "lstore", _, 2 -> add 1 (JCode.OpStore (`Long, 2))
                  | "lstore", _, 3 -> add 1 (JCode.OpStore (`Long, 3))
                  | "lstore", "i", l -> add 2 (JCode.OpStore (`Long, l))
                  | "lstore", "I", l -> add 3 (JCode.OpStore (`Long, l))
                  (* R *)
                  | "ret", "i", n -> add 2 (JCode.OpRet n)
                  | "ret", "I", n -> add 3 (JCode.OpRet n)
                  (* S *)
                  | "sipush", "i", n -> add 3 (JCode.OpSIPush n)
                  | a,b,i1 ->
                    Printf.printf "InstInt(%S, %S, %d)@." a b i1;
                    assert false
                )
# 2839 "parser.ml"
               : 'simple_instruction))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string * string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1372 "parser.mly"
                           (
                  match(fst _1,snd _1, _2)with
                  (* I *)
                  | "ldc", "constant", s -> add 2 (JCode.OpFConst( (float_of_string s)))
                  | "ldc2_w", "bigconstant", d -> add 3 (JCode.OpDConst( (float_of_string d)))
                  | a,b,s ->
                    Printf.printf "InstNum(%S, %S, %S)@." a b s;
                    assert false
                )
# 2855 "parser.ml"
               : 'simple_instruction))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string * string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1381 "parser.mly"
                            ( 
                  match(fst _1,snd _1, _2)with
                  (* A *)
                  | "anewarray", "class", o ->
                  add 3 (JCode.OpANewArray (const !ctx (ConstClass (JReader.expand_path o))))
                  (* C *)
                  | "checkcast", "class", w ->
                    add 3 (JCode.OpCheckCast (const !ctx (ConstClass (JReader.expand_path w))))
                  (* G *)
                  | "goto", "label", l -> add 3 (JCode.OpGoto(label2int l))
                  | "goto_w", "label", l -> add 3 (JCode.OpGoto(label2int l))
                  (* I *)
                  | "if_acmpeq", "label", l -> add 3 (JCode.OpACmpEq (label2int l))
                  | "if_acmpne", "label", l -> add 3 (JCode.OpACmpNe (label2int l))
                  | "if_icmpeq", "label", l -> add 3 (JCode.OpICmpEq (label2int l))
                  | "if_icmpge", "label", l -> add 3 (JCode.OpICmpGe (label2int l))
                  | "if_icmpgt", "label", l -> add 3 (JCode.OpICmpGt (label2int l))
                  | "if_icmple", "label", l -> add 3 (JCode.OpICmpLe (label2int l))
                  | "if_icmplt", "label", l -> add 3 (JCode.OpICmpLt (label2int l))
                  | "if_icmpne", "label", l -> add 3 (JCode.OpICmpNe (label2int l))
                  | "ifeq", "label", l -> add 3 (JCode.OpIfEq (label2int l))
                  | "ifge", "label", l -> add 3 (JCode.OpIfGe (label2int l))
                  | "ifgt", "label", l -> add 3 (JCode.OpIfGt (label2int l))
                  | "ifle", "label", l -> add 3 (JCode.OpIfLe (label2int l))
                  | "iflt", "label", l -> add 3 (JCode.OpIfLt (label2int l))
                  | "ifne", "label", l -> add 3 (JCode.OpIfNe (label2int l))
                  | "instanceof", "class", o -> add 3 (JCode.OpInstanceOf (const !ctx (ConstClass (JReader.expand_path o))))
                  | "invokenonvirtual", "method", m ->
                    debug "invoke method@.";
                    let (obj,f) = split_method m in
                    debug "koko1 %s@." obj;
                    let (name,o) = split_obj obj in
                    debug "koko2@.";
                    let jpath = JReader.expand_path name in
                    debug "koko3@.";
                    let f = JReader.parse_method_signature f in
                    debug "koko4@.";
                    let i = const !ctx (ConstMethod (jpath, o, f)) in
                    debug "invoke method %d@." i;
                    add 3 (JCode.OpInvokeNonVirtual i)
                  | "invokestatic", "method", m ->
                    let (obj,f) = split_method m in
                    let (name,o) = split_obj obj in
                    let jpath = JReader.expand_path name in
                    let f = JReader.parse_method_signature f in
                    let i = const !ctx (ConstMethod (jpath, o, f)) in
                    add 3 (JCode.OpInvokeStatic i)
                    (*
                    add 3(JCode.OpInvoke (`Static (JBasics.make_cn name), JBasics.make_ms o args r))
                    *)
                  | "invokevirtual", "method", m ->
                    let (obj,f) = split_method m in
                    let (name,o) = split_obj obj in
                    let jpath = JReader.expand_path name in
                    let f = JReader.parse_method_signature f in
                    let i = const !ctx (ConstMethod (jpath, o, f)) in
                    add 3 (JCode.OpInvokeVirtual i)
                    
                    (*add 3(JCode.OpInvoke (`Virtual ((JBasics.TClass (JBasics.make_cn name))), JBasics.make_ms o args r))*)
                  (* J *)
                  | "jsr","label",label -> add 3 (JCode.OpJsr((label2int label)))
                  | "jsr_w","label",label -> add 3 (JCode.OpJsr((label2int label)))
                  | "ldc", "constant", d -> add 2 (JCode.OpFConst( (float_of_string d)))
                  | "ldc2_w", "bigconstant", d -> add 3 (JCode.OpDConst( (float_of_string d)))
                  (* N *)
                  | "new", "class", o -> add 3 (JCode.OpNew (const !ctx (ConstClass (JReader.expand_path (replace_dot o)))))
                  | "newarray", "atype", t ->
                    let a = java_basic_type_of_string t in
                    add 2 (JCode.OpNewArray a)
                  | a,b,s ->
                    Printf.printf "InstWord(%S, %S, %S)@." a b s;
                    assert false
                )
# 2935 "parser.ml"
               : 'simple_instruction))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : string * string) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : int) in
    Obj.repr(
# 1454 "parser.mly"
                                (
                  match(fst _1,snd _1, _2,_3)with
                  (* I *)
                  | "invokeinterface", "interface", m, i2 ->
                    let (obj,f) = split_method m in
                    let (name,o) = split_obj obj in
                    let jpath = JReader.expand_path name in
                    let f = JReader.parse_method_signature f in
                    let i = const !ctx (ConstMethod (jpath, o, f)) in
                    add 5(JCode.OpInvokeInterface (i, i2))
                  (* M *)
                  | "multianewarray", "marray", t, i ->
                    add 4 (JCode.OpAMultiNewArray (const !ctx (ConstClass (JReader.expand_path t)), i))
                  | a,b,s,i ->
                    Printf.printf "InstWordInt(%S, %S, %S, %d)@." a b s i;
                    assert false
                )
# 2960 "parser.ml"
               : 'simple_instruction))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : string * string) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1471 "parser.mly"
                                 (
                  match(fst _1, _2,_3)with
                  | "getfield", cf, fd ->
                    let (c,f) = split_obj(cf) in
                    let jpath = JReader.expand_path c in
                    let fd = JReader.parse_signature fd in
                    add 3 (JCode.OpGetField (const !ctx (ConstField(jpath,f,fd))))
                  | "getstatic", cf, fd ->
                    let (c,f) = split_obj(cf) in
                    let jpath = JReader.expand_path c in
                    let fd = JReader.parse_signature fd in
                    add 3 (JCode.OpGetStatic (const !ctx (ConstField(jpath,f,fd))))
                  | "putfield", cf, fd ->
                    let (c,f) = split_obj(cf) in
                    let jpath = JReader.expand_path c in
                    let fd = JReader.parse_signature fd in
                    add 3 (JCode.OpPutField (const !ctx (ConstField(jpath,f,fd))))
                  | "putstatic", cf, fd ->
                    let (c,f) = split_obj(cf) in
                    let jpath = JReader.expand_path c in
                    let fd = JReader.parse_signature fd in
                    add 3 (JCode.OpPutStatic (const !ctx (ConstField(jpath,f,fd))))
                  | a, b, s2 ->
                    Printf.printf "InstWordWord(%S, %S, %S, %S)@." a b (snd _1) s2;
                    assert false
                )
# 2994 "parser.ml"
               : 'simple_instruction))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string * string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1497 "parser.mly"
                           ( 
                  match(fst _1,snd _1, unescape _2)with
                  | "ldc", "constant", s -> add 2 (JCode.OpLdc1(const !ctx(ConstUtf8 s)))
                  | a,b,s ->
                    Printf.printf "InstStr(%S, %S, %S)@." a b s;
                    assert false
                )
# 3008 "parser.ml"
               : 'simple_instruction))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string * string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1504 "parser.mly"
                                (
                  match(fst _1, snd _1,_2)with
                  | a,b,s ->
                    Printf.printf "InstRelative(%S, %S, %S)@." a b s;
                    assert false
                )
# 3021 "parser.ml"
               : 'simple_instruction))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lookup) in
    Obj.repr(
# 1515 "parser.mly"
                                      ( _2 )
# 3028 "parser.ml"
               : 'complex_instruction))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'table) in
    Obj.repr(
# 1516 "parser.mly"
                                    ( _2 )
# 3035 "parser.ml"
               : 'complex_instruction))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'lookup_args) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'lookup_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'lookup_default) in
    Obj.repr(
# 1525 "parser.mly"
                    (
                      let a =
                        match _3 with
                        | DefaultInt i -> i
                        | DefaultWord l -> label2int l
                      in
                      let ls = List.map(function
                        | CaseIntInt(i, j)-> (Int32.of_int i, j)
                        | CaseIntWord(i, j) -> (Int32.of_int i, (label2int j))
                      ) _2 in
                      let padding_size = (4 - (!pos + 1) mod 4) mod 4 in
                      let n = 9 + padding_size + 8 * (List.length _2) in
                      add n (JCode.OpLookupSwitch (a, ls))

                    )
# 3058 "parser.ml"
               : 'lookup))
; (fun __caml_parser_env ->
    Obj.repr(
# 1542 "parser.mly"
                          ( () )
# 3064 "parser.ml"
               : 'lookup_args))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'lookup_entry) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lookup_list) in
    Obj.repr(
# 1545 "parser.mly"
                                               ( _1 :: _2 )
# 3072 "parser.ml"
               : 'lookup_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'lookup_entry) in
    Obj.repr(
# 1546 "parser.mly"
                                   ( [_1] )
# 3079 "parser.ml"
               : 'lookup_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : int) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : string) in
    Obj.repr(
# 1549 "parser.mly"
                                           ( CaseIntWord(_1,_3) )
# 3087 "parser.ml"
               : 'lookup_entry))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : int) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : int) in
    Obj.repr(
# 1550 "parser.mly"
                                          ( CaseIntInt(_1,_3) )
# 3095 "parser.ml"
               : 'lookup_entry))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1553 "parser.mly"
                                         ( DefaultWord _3 )
# 3102 "parser.ml"
               : 'lookup_default))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 0 : int) in
    Obj.repr(
# 1554 "parser.mly"
                                        ( DefaultInt _3 )
# 3109 "parser.ml"
               : 'lookup_default))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'table_args) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'table_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'table_default) in
    Obj.repr(
# 1563 "parser.mly"
                    (
                      (* T *)
                      let (low,high,defs,def) = (fst _1,snd _1,_2,_3) in
                      let default2int = function
                        | DefaultInt i -> i
                        | DefaultWord l -> label2int l
                      in
                      let defs = List.map default2int defs in
                      let defs = Array.of_list defs in
                      let padding_size = (4 - ((!pos + 1) mod 4)) mod 4 in
                      let n = 13 + padding_size + 4 * (Array.length defs) in
                      let high = if high = -1 then Array.length defs - 1 + low else high in
                      add n (JCode.OpTableSwitch ((default2int def), Int32.of_int low, Int32.of_int high, defs))
                    )
# 3131 "parser.ml"
               : 'table))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : int) in
    Obj.repr(
# 1579 "parser.mly"
                              ( (_1,-1) )
# 3138 "parser.ml"
               : 'table_args))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : int) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in
    Obj.repr(
# 1580 "parser.mly"
                                  ( (_1, _2) )
# 3146 "parser.ml"
               : 'table_args))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'table_entry) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'table_list) in
    Obj.repr(
# 1583 "parser.mly"
                                             ( _1::_2 )
# 3154 "parser.ml"
               : 'table_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'table_entry) in
    Obj.repr(
# 1584 "parser.mly"
                                  ( [_1] )
# 3161 "parser.ml"
               : 'table_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    Obj.repr(
# 1587 "parser.mly"
                                 ( DefaultWord(_1) )
# 3168 "parser.ml"
               : 'table_entry))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : int) in
    Obj.repr(
# 1588 "parser.mly"
                                ( DefaultInt(_1) )
# 3175 "parser.ml"
               : 'table_entry))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1591 "parser.mly"
                                         ( DefaultWord(_3) )
# 3182 "parser.ml"
               : 'table_default))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 0 : int) in
    Obj.repr(
# 1592 "parser.mly"
                                        ( DefaultInt(_3) )
# 3189 "parser.ml"
               : 'table_default))
(* Entry jas_file *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
|]
let yytables =
  { Parsing.actions=yyact;
    Parsing.transl_const=yytransl_const;
    Parsing.transl_block=yytransl_block;
    Parsing.lhs=yylhs;
    Parsing.len=yylen;
    Parsing.defred=yydefred;
    Parsing.dgoto=yydgoto;
    Parsing.sindex=yysindex;
    Parsing.rindex=yyrindex;
    Parsing.gindex=yygindex;
    Parsing.tablesize=yytablesize;
    Parsing.table=yytable;
    Parsing.check=yycheck;
    Parsing.error_function=parse_error;
    Parsing.names_const=yynames_const;
    Parsing.names_block=yynames_block }
let jas_file (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 1 lexfun lexbuf : jclass)
